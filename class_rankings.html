<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAKP Class Rankings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header a {
            color: white;
            text-decoration: underline;
            font-size: 0.9em;
            margin-top: 10px;
            display: inline-block;
        }

        header a:hover {
            color: #f0f0f0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
        }

        .score-breakdown {
            margin-top: 20px;
        }

        .score-breakdown h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .score-breakdown table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .score-breakdown th,
        .score-breakdown td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .score-breakdown th {
            background-color: #667eea;
            color: white;
        }

        .score-breakdown tr:hover {
            background-color: #f5f5f5;
        }

        .clickable-row {
            cursor: pointer;
        }

        .clickable-row:hover {
            background-color: #f0f0f0;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #495057;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }

        .table-container {
            overflow-x: auto;
            max-height: 75vh;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;  /* Allow columns to resize when others are hidden */
        }

        thead {
            position: sticky;
            top: 0;
            background: #667eea;
            color: white;
            z-index: 10;
        }

        th {
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
        }

        tbody tr {
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
        }

        tbody tr:hover {
            background-color: #f8f9fa;
        }

        td {
            padding: 12px 10px;
            font-size: 13px;
        }

        .rank {
            font-weight: 700;
            color: #667eea;
            text-align: center;
        }

        .name {
            font-weight: 600;
        }

        .name a {
            color: #667eea;
            text-decoration: none;
        }

        .name a:hover {
            text-decoration: underline;
        }

        .score {
            text-align: right;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .score.high {
            color: #28a745;
        }

        .score.medium {
            color: #ffc107;
        }

        .score.low {
            color: #dc3545;
        }

        .focus-badge {
            display: inline-block;
            background: #e7f3ff;
            color: #667eea;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            margin: 2px;
        }

        .focus-breakdown-section { margin-top: 24px; padding: 16px; background: linear-gradient(135deg, #f8f9fc 0%, #eef1f8 100%); border-radius: 8px; border: 1px solid #dee2e6; }
        .focus-breakdown-section h3 { margin: 0 0 12px 0; color: #333; font-size: 1.1em; }
        .focus-breakdown-item { margin-bottom: 14px; }
        .focus-breakdown-name { font-weight: 600; color: #495057; margin-bottom: 4px; }
        .focus-breakdown-bar-wrap { height: 22px; background: #e9ecef; border-radius: 6px; overflow: hidden; margin-bottom: 4px; }
        .focus-breakdown-bar { height: 100%; border-radius: 6px; transition: width 0.3s ease; min-width: 2px; }
        .focus-breakdown-bar.high { background: linear-gradient(90deg, #28a745, #20c997); }
        .focus-breakdown-bar.mid { background: linear-gradient(90deg, #ffc107, #fd7e14); }
        .focus-breakdown-bar.low { background: linear-gradient(90deg, #dc3545, #e83e8c); }
        .focus-breakdown-bar.none { background: #adb5bd; }
        .focus-breakdown-value { font-size: 0.85em; color: #6c757d; }
        .focus-breakdown-sources { font-size: 0.85em; color: #495057; margin-top: 2px; }
        .focus-breakdown-sources a { color: #667eea; text-decoration: none; }
        .focus-breakdown-sources a:hover { text-decoration: underline; }

        .loading, .error {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-size: 18px;
        }

        .error {
            color: #dc3545;
        }

        /* Item card — Magelo-style, matches local purple theme (#667eea / #764ba2) */
        .item-link { cursor: pointer; }
        .item-card {
            --item-card-bg: #fefefe;
            --item-card-border: #667eea;
            --item-card-name: #667eea;
            min-width: 260px;
            max-width: 320px;
            background: var(--item-card-bg);
            border: 1px solid var(--item-card-border);
            border-radius: 8px;
            font-size: 0.8125rem;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.25);
            overflow: hidden;
        }
        .item-card--compact { min-width: 180px; max-width: 280px; }
        .item-card--compact .ItemInner { display: none; }
        .ItemOuter .ItemTitle {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 0.4rem 0.6rem;
            border-bottom: 1px solid var(--item-card-border);
        }
        .ItemTitleLeft, .ItemTitleRight { flex: 0 0 0; }
        .ItemTitleMid { flex: 1; text-align: center; min-width: 0; }
        .ItemTitleMid a { color: white; font-weight: 700; text-decoration: none; }
        .ItemTitleMid a:hover { text-decoration: underline; }
        .ItemInner {
            text-align: left;
            padding: 0.5rem 0.75rem;
            color: #333;
            line-height: 1.45;
        }
        .ItemInner br { display: block; content: ""; margin-top: 0.15rem; }
        .item-card__spell-link { color: #764ba2; text-decoration: none; }
        .item-card__spell-link:hover { text-decoration: underline; }
        .ItemInner i { color: #6c757d; font-style: italic; }
        .item-card-popover {
            position: fixed;
            z-index: 10000;
            padding: 8px;
            animation: item-card-fade 0.15s ease-out;
        }
        @keyframes item-card-fade {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>TAKP Class Rankings</h1>
            <p>Level 65 Character Rankings with Focus Analysis</p>
            <a href="scoring_explanation.html">How are scores calculated?</a>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Filter Class:</label>
                <select id="filterClass">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div class="control-group">
                <label>Search Name:</label>
                <input type="text" id="searchName" placeholder="Partial name..." style="padding: 8px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 14px; min-width: 160px;">
            </div>
            <div class="control-group">
                <label>Sort by:</label>
                <select id="sortBy">
                    <option value="overall">Overall Score</option>
                    <option value="class_rank">Class Rank</option>
                    <option value="hp">HP %</option>
                    <option value="mana">Mana %</option>
                    <option value="ac">AC %</option>
                    <option value="atk">ATK %</option>
                    <option value="focus">Focus Score</option>
                </select>
            </div>
            <div class="control-group">
                <button id="toggleWeights" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Customize Weights
                </button>
            </div>
        </div>

        <div id="weightPanel" style="display: none; background: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 8px; border: 1px solid #dee2e6;">
            <h3 style="margin-top: 0;">Custom Weight Adjustment</h3>
            <p style="color: #6c757d; font-size: 0.9em;">Adjust stat and focus weights to customize rankings. Changes are saved locally and apply to the selected class.</p>
            <div style="margin-bottom: 15px;">
                <label><strong>Class:</strong></label>
                <select id="weightClass" style="margin-left: 10px; padding: 5px;">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div id="weightSliders" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <!-- Sliders will be generated here -->
            </div>
            <div id="focusWeightSliders" style="margin-top: 20px; display: none;">
                <!-- Focus weight sliders will be generated here -->
            </div>
            <div style="margin-top: 20px;">
                <label style="display: flex; align-items: center; margin-bottom: 15px;">
                    <input type="checkbox" id="advancedResists" checked style="margin-right: 8px; width: 18px; height: 18px;">
                    <strong>Advanced Resists</strong>
                    <span style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">
                        (Individual resist scoring: Full weight up to 220, linear decrease to 0.35 at 320, 0.35 from 320-500, 0 above 500)
                    </span>
                </label>
            </div>
            <div style="margin-top: 20px;">
                <button id="resetWeights" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                    Reset to Default
                </button>
                <button id="applyWeights" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Apply Weights
                </button>
            </div>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">Loading rankings data...</div>
            <div id="error" class="error" style="display: none;"></div>
            <table id="rankingsTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Class Rank</th>
                        <th>Name</th>
                        <th>Guild</th>
                        <th>Class</th>
                        <th>Overall</th>
                        <th class="stat-col" data-stat="hp">HP</th>
                        <th class="stat-col" data-stat="mana">Mana</th>
                        <th class="stat-col" data-stat="ac">AC</th>
                        <th class="stat-col" data-stat="atk">ATK</th>
                        <th class="stat-col" data-stat="resists">Resists</th>
                        <th>Focus %</th>
                        <th class="stat-col" data-stat="spelldmg">Spell Dmg %</th>
                        <th>Damage Types</th>
                        <th>Other Focii</th>
                    </tr>
                </thead>
                <tbody id="rankingsBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Score Breakdown Modal -->
    <div id="scoreModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        let characters = [];
        let filteredCharacters = [];
        let filterClass = '';
        let nameSearch = '';
        let sortBy = 'overall';

        let classWeights = {};
        let normalizedClassWeights = {}; // Backend-normalized weights (focus ~35%, FT in focus); use for card when no custom
        let customWeights = {}; // User-customized weights
        let originalClassWeights = {}; // Backup of original weights
        let focusCandidates = {}; // focus_key -> list of { item_name, item_id, value, classes? } for items that could give that focus

        // Full class name -> EQ class abbreviation (for filtering items by usable class)
        const CLASS_TO_ABBREV = { 'Warrior': 'WAR', 'Cleric': 'CLR', 'Paladin': 'PAL', 'Ranger': 'RNG', 'Shadow Knight': 'SHD', 'Druid': 'DRU', 'Monk': 'MNK', 'Bard': 'BRD', 'Rogue': 'ROG', 'Shaman': 'SHM', 'Necromancer': 'NEC', 'Wizard': 'WIZ', 'Magician': 'MAG', 'Enchanter': 'ENC', 'Beastlord': 'BST' };

        /** Return numeric weight for a focus category (handles nested e.g. Spell Damage). */
        function getFocusWeight(cat, focusWeights) {
            if (!focusWeights) return 0;
            const w = focusWeights[cat];
            if (typeof w === 'number') return w;
            if (typeof w === 'object' && w !== null) return Object.values(w).reduce((a, b) => a + b, 0);
            return 0;
        }

        /** Return numeric weight for a focus key (e.g. "Spell Damage (Fire)" -> focusWeights['Spell Damage']['Fire']). */
        function getWeightForFocusKey(focusKey, focusWeights) {
            if (!focusWeights) return 0;
            const match = focusKey.match(/^(.+)\s+\(([^)]+)\)$/);
            if (match) {
                const [, parent, sub] = match;
                const parentW = focusWeights[parent];
                if (typeof parentW === 'object' && parentW !== null && parentW[sub] !== undefined) return parentW[sub];
                return 0;
            }
            const w = focusWeights[focusKey];
            return typeof w === 'number' ? w : 0;
        }

        /** Filter focus candidates to upgrades only (value > current raw) and items usable by charClass. */
        function filterFocusCandidates(candidates, currentRawValue, charClass) {
            if (!candidates || candidates.length === 0) return [];
            const abbrev = charClass ? CLASS_TO_ABBREV[charClass] : null;
            const currentRaw = (currentRawValue != null && currentRawValue !== '') ? Number(currentRawValue) : 0;
            return candidates.filter(s => {
                const val = (s.value != null && s.value !== '') ? Number(s.value) : 0;
                if (val <= currentRaw) return false; // downgrade or same – hide
                if (abbrev && s.classes) {
                    const classes = (s.classes || '').trim().toUpperCase();
                    if (classes === 'ALL') return true;
                    const list = classes.split(/\s+/);
                    if (list.indexOf(abbrev) === -1) return false; // not usable by this class
                }
                return true;
            });
        }

        // Weight customization functions
        function loadCustomWeights() {
            const saved = localStorage.getItem('customWeights');
            if (saved) {
                try {
                    customWeights = JSON.parse(saved);
                    // Apply custom weights
                    applyCustomWeights();
                } catch (e) {
                    console.error('Error loading custom weights:', e);
                }
            }
        }

        function saveCustomWeights() {
            localStorage.setItem('customWeights', JSON.stringify(customWeights));
        }

        function applyCustomWeights() {
            // Merge custom weights into classWeights
            for (const [className, customWeight] of Object.entries(customWeights)) {
                if (classWeights[className]) {
                    Object.assign(classWeights[className], customWeight);
                }
            }
        }

        function setupWeightControls() {
            // Populate class selector for weights
            const weightClassSelect = document.getElementById('weightClass');
            if (!weightClassSelect) return; // Panel might not exist yet
            
            const classes = new Set(characters.map(c => c.class).filter(c => c));
            [...classes].sort().forEach(cls => {
                const option = document.createElement('option');
                option.value = cls;
                option.textContent = cls;
                weightClassSelect.appendChild(option);
            });

            // Toggle weight panel
            const toggleBtn = document.getElementById('toggleWeights');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    const panel = document.getElementById('weightPanel');
                    if (panel) {
                        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                        if (panel.style.display === 'block') {
                            // Default to currently filtered class when opening Customize Weights
                            const weightClassSelect = document.getElementById('weightClass');
                            if (weightClassSelect && filterClass && weightClassSelect.querySelector(`option[value="${filterClass}"]`)) {
                                weightClassSelect.value = filterClass;
                            }
                            updateWeightSliders();
                        }
                    }
                });
            }

            // Class selector change
            weightClassSelect.addEventListener('change', () => {
                updateWeightSliders();
            });

            // Advanced resists checkbox
            const advancedResistsCheckbox = document.getElementById('advancedResists');
            if (advancedResistsCheckbox) {
                // Load saved preference
                const savedAdvancedResists = localStorage.getItem('advancedResists');
                if (savedAdvancedResists !== null) {
                    advancedResists = savedAdvancedResists === 'true';
                    advancedResistsCheckbox.checked = advancedResists;
                }
                
                advancedResistsCheckbox.addEventListener('change', () => {
                    advancedResists = advancedResistsCheckbox.checked;
                    localStorage.setItem('advancedResists', advancedResists.toString());
                });
            }

            // Apply weights button
            const applyBtn = document.getElementById('applyWeights');
            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    saveWeightValues();
                    applyCustomWeights();
                    recalculateScores();
                    filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                });
            }

            // Reset weights button
            const resetBtn = document.getElementById('resetWeights');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    const selectedClass = document.getElementById('weightClass').value;
                    if (selectedClass && customWeights[selectedClass]) {
                        delete customWeights[selectedClass];
                        saveCustomWeights();
                        // Restore original weights
                        if (originalClassWeights[selectedClass]) {
                            classWeights[selectedClass] = JSON.parse(JSON.stringify(originalClassWeights[selectedClass]));
                        }
                        updateWeightSliders();
                        recalculateScores();
                        filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                    } else if (!selectedClass) {
                        // Reset all
                        customWeights = {};
                        saveCustomWeights();
                        classWeights = JSON.parse(JSON.stringify(originalClassWeights));
                        updateWeightSliders();
                        recalculateScores();
                        filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                    }
                });
            }
        }

        function updateWeightSliders() {
            const selectedClass = document.getElementById('weightClass')?.value;
            const slidersDiv = document.getElementById('weightSliders');
            if (!slidersDiv) return;
            
            slidersDiv.innerHTML = '';

            if (!selectedClass) {
                slidersDiv.innerHTML = '<p style="color: #6c757d;">Select a class to customize weights</p>';
                return;
            }

            // Build weights the same way as recalculateScores so contribution % matches scoring and sums to 100%
            let weights = JSON.parse(JSON.stringify(originalClassWeights[selectedClass] || classWeights[selectedClass] || {}));
            const customWeight = customWeights[selectedClass] || {};
            const allStatKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
            allStatKeys.forEach(k => {
                if (customWeight[k] !== undefined) weights[k] = customWeight[k];
            });
            Object.keys(customWeight).forEach(key => {
                if (key !== '_meta' && key !== 'focus' && !allStatKeys.includes(key) && weights.hasOwnProperty(key)) {
                    weights[key] = customWeight[key];
                }
            });
            if (customWeight.focus && weights.focus) {
                Object.keys(customWeight.focus).forEach(focusKey => {
                    if (typeof customWeight.focus[focusKey] === 'object' && customWeight.focus[focusKey] !== null) {
                        if (!weights.focus[focusKey]) weights.focus[focusKey] = {};
                        Object.keys(customWeight.focus[focusKey]).forEach(nestedKey => {
                            if (weights.focus[focusKey][nestedKey] !== undefined) {
                                weights.focus[focusKey][nestedKey] = customWeight.focus[focusKey][nestedKey];
                            }
                        });
                    } else {
                        if (weights.focus[focusKey] !== undefined) {
                            weights.focus[focusKey] = customWeight.focus[focusKey];
                        }
                    }
                });
            }
            // When user customized stats but not focus (or focus sum is 0), use stats-only so contribution shows 100% stats
            const hasCustomStatHere = allStatKeys.some(k => customWeight[k] !== undefined);
            const focusSumHere = (customWeight.focus && typeof customWeight.focus === 'object') ? sumFocusWeights(customWeight.focus) : -1;
            if (hasCustomStatHere && (focusSumHere === 0 || focusSumHere === -1) && (weights.hp_pct || weights.mana_pct || weights.ac_pct || weights.resists_pct)) {
                weights.focus = {};
            }
            allStatKeys.forEach(key => {
                if (weights[key] === undefined) weights[key] = 0.0;
            });

            // Normalized weights: 0.65 to stats (or 1.0 when all focus weights 0), 0.35 to focus; contributions sum to 100%
            const _cw = customWeights[selectedClass];
            const _meta = _cw && _cw._meta;
            const _fromCustom = _meta != null && _meta.focusMultiplier != null ? _meta.focusMultiplier : null;
            const focusMult = _fromCustom != null ? _fromCustom : 2.4;
            const normalized = normalizeWeights(weights, focusMult, selectedClass);
            
            // All stats are always shown, even if default is 0
            // This allows users to enable stats that are 0 by default (e.g., AC for casters, Mana for melees)
            const statKeys = [
                { key: 'hp_pct', label: 'HP', default: 1.0 },
                { key: 'mana_pct', label: 'Mana', default: 0.0 },  // Can be enabled even if class doesn't have mana
                { key: 'ac_pct', label: 'AC', default: 0.0 },  // Can be enabled even if class doesn't have AC
                { key: 'resists_pct', label: 'Resists', default: 1.0 }
            ];

            statKeys.forEach(stat => {
                // Use the actual weight value, even if it's 0 (so AC can be adjusted for casters)
                const rawValue = weights[stat.key] !== undefined ? weights[stat.key] : stat.default;
                const normalizedValue = normalized[stat.key] || 0;
                const sliderDiv = document.createElement('div');
                sliderDiv.style.padding = '10px';
                sliderDiv.style.background = 'white';
                sliderDiv.style.borderRadius = '4px';
                sliderDiv.innerHTML = `
                    <label style="display: block; margin-bottom: 5px;">
                        <strong>${stat.label}:</strong> 
                        <span id="value_${stat.key}">${rawValue.toFixed(2)}</span>
                        <span id="contrib_${stat.key}" style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">
                            (${(normalizedValue * 100).toFixed(1)}% contribution)
                        </span>
                    </label>
                    <input type="range" 
                           id="slider_${stat.key}" 
                           min="0" 
                           max="3" 
                           step="0.1" 
                           value="${rawValue}" 
                           style="width: 100%;"
                           oninput="updateSliderValue('${stat.key}', this.value)">
                    ${normalizedValue === 0 && rawValue === 0 ? '<p style="font-size: 0.85em; color: #6c757d; margin: 5px 0 0 0; font-style: italic;">Increase this value to enable this stat in scoring</p>' : ''}
                `;
                slidersDiv.appendChild(sliderDiv);
            });

            // Show that contributions sum to 100% (stats + focus when focus used, else stats only)
            const statContribSum = (normalized.hp_pct + normalized.mana_pct + normalized.ac_pct + normalized.resists_pct) * 100;
            const focusContribSum = normalized.focusTarget * 100;
            const totalContrib = statContribSum + focusContribSum;
            const summaryDiv = document.createElement('p');
            summaryDiv.id = 'weightContribSummary';
            summaryDiv.style.cssText = 'font-size: 0.9em; color: #6c757d; margin: 8px 0 0 0; padding: 6px 10px; background: #f0f0f0; border-radius: 4px;';
            if (focusContribSum > 0) {
                summaryDiv.textContent = `Contributions sum to ${totalContrib.toFixed(1)}% (Stats: ${statContribSum.toFixed(1)}%, Focus: ${focusContribSum.toFixed(1)}%)`;
            } else {
                summaryDiv.textContent = `Contributions sum to ${totalContrib.toFixed(1)}% (Stats: 100% when all focus weights are 0)`;
            }
            slidersDiv.appendChild(summaryDiv);

            // Add focus weight customization section
            const focusSlidersDiv = document.getElementById('focusWeightSliders');
            if (focusSlidersDiv) {
                focusSlidersDiv.innerHTML = '';
                focusSlidersDiv.style.display = 'block';
                
                const focusWeights = weights.focus || {};
                const customFocusWeights = customWeights[selectedClass]?.focus || {};
                
                if (Object.keys(focusWeights).length === 0) {
                    focusSlidersDiv.innerHTML = '<p style="color: #6c757d; padding: 10px;">This class has no focus weights configured.</p>';
                } else {
                    function setAllFocusSlidersTo(val) {
                        const panel = document.getElementById('focusWeightSliders');
                        if (!panel) return;
                        panel.querySelectorAll('input[type="range"]').forEach(input => {
                            input.value = val;
                            const valueId = input.id.replace('slider_', 'value_');
                            const span = document.getElementById(valueId);
                            if (span) span.textContent = parseFloat(val).toFixed(2);
                        });
                    }
                    function restoreDefaultFocusWeights() {
                        const defaults = originalClassWeights[selectedClass]?.focus ?? classWeights[selectedClass]?.focus ?? {};
                        for (const [focusKey, focusVal] of Object.entries(defaults)) {
                            if (typeof focusVal === 'object' && focusVal !== null) {
                                for (const [nestedKey, v] of Object.entries(focusVal)) {
                                    const sliderId = `slider_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                    const valueId = `value_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                    const slider = document.getElementById(sliderId);
                                    if (slider) { slider.value = v; const span = document.getElementById(valueId); if (span) span.textContent = parseFloat(v).toFixed(2); }
                                }
                            } else {
                                const sliderId = `slider_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                const valueId = `value_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                const slider = document.getElementById(sliderId);
                                if (slider) { slider.value = focusVal; const span = document.getElementById(valueId); if (span) span.textContent = parseFloat(focusVal).toFixed(2); }
                            }
                        }
                    }
                    const headerDiv = document.createElement('div');
                    headerDiv.style.marginBottom = '15px';
                    headerDiv.style.padding = '10px';
                    headerDiv.style.background = '#e7f3ff';
                    headerDiv.style.borderRadius = '4px';
                    headerDiv.innerHTML = `
                        <h4 style="margin: 0;">Focus Weights</h4>
                        <p style="margin: 5px 0 0 0; font-size: 0.9em; color: #6c757d;">
                            Adjust individual focus category weights. 0 = off; non-zero values are relative (same scale as stat sliders).
                        </p>
                        <label style="display: flex; align-items: center; margin-top: 10px; cursor: pointer;">
                            <input type="checkbox" id="focusWeightsEnabled" checked style="margin-right: 8px; width: 18px; height: 18px;">
                            <strong>Use focus weights</strong>
                            <span style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">(uncheck to set all to 0)</span>
                        </label>
                        <div style="margin-top: 8px;">
                            <button type="button" id="focusWeightsSetZero" style="padding: 6px 12px; margin-right: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">Set all to 0</button>
                            <button type="button" id="focusWeightsRestoreDefaults" style="padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">Restore defaults</button>
                        </div>
                    `;
                    focusSlidersDiv.appendChild(headerDiv);
                    
                    const focusGrid = document.createElement('div');
                    focusGrid.style.display = 'grid';
                    focusGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
                    focusGrid.style.gap = '15px';
                    focusGrid.style.marginTop = '15px';
                    
                    // Sort focus categories for consistent display; include keys from custom so 0-weight can be adjusted
                    const focusKeys = [...new Set([...Object.keys(focusWeights || {}), ...Object.keys(customFocusWeights || {})])].sort();
                    
                    focusKeys.forEach(focusKey => {
                        const focusValue = customFocusWeights[focusKey] !== undefined ? customFocusWeights[focusKey] : (focusWeights[focusKey] !== undefined ? focusWeights[focusKey] : 0);
                        
                        if (typeof focusValue === 'object' && focusValue !== null) {
                            // Nested object (e.g., Spell Damage with damage types)
                            const nestedDiv = document.createElement('div');
                            nestedDiv.style.padding = '10px';
                            nestedDiv.style.background = 'white';
                            nestedDiv.style.borderRadius = '4px';
                            nestedDiv.style.border = '1px solid #dee2e6';
                            
                            let nestedHtml = `<div style="margin-bottom: 10px;"><strong>${focusKey}:</strong></div>`;
                            
                            const nestedKeys = Object.keys(focusValue).sort();
                            nestedKeys.forEach(nestedKey => {
                                const currentValue = customFocusWeights[focusKey]?.[nestedKey] !== undefined 
                                    ? customFocusWeights[focusKey][nestedKey] 
                                    : focusValue[nestedKey];
                                const sliderId = `slider_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                const valueId = `value_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                
                                nestedHtml += `
                                    <div style="margin-bottom: 10px;">
                                        <label style="display: block; margin-bottom: 5px;">
                                            <strong>${nestedKey}:</strong> 
                                            <span id="${valueId}">${currentValue.toFixed(2)}</span>
                                        </label>
                                        <input type="range" 
                                               id="${sliderId}" 
                                               min="0" 
                                               max="3" 
                                               step="0.1" 
                                               value="${currentValue}" 
                                               style="width: 100%;"
                                               oninput="document.getElementById('${valueId}').textContent = parseFloat(this.value).toFixed(2)">
                                    </div>
                                `;
                            });
                            
                            nestedDiv.innerHTML = nestedHtml;
                            focusGrid.appendChild(nestedDiv);
                        } else {
                            // Simple numeric value
                            const currentValue = customFocusWeights[focusKey] !== undefined ? customFocusWeights[focusKey] : focusValue;
                            const sliderId = `slider_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                            const valueId = `value_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                            
                            const sliderDiv = document.createElement('div');
                            sliderDiv.style.padding = '10px';
                            sliderDiv.style.background = 'white';
                            sliderDiv.style.borderRadius = '4px';
                            sliderDiv.innerHTML = `
                                <label style="display: block; margin-bottom: 5px;">
                                    <strong>${focusKey}:</strong> 
                                    <span id="${valueId}">${currentValue.toFixed(2)}</span>
                                </label>
                                <input type="range" 
                                       id="${sliderId}" 
                                       min="0" 
                                       max="3" 
                                       step="0.1" 
                                       value="${currentValue}" 
                                       style="width: 100%;"
                                       oninput="document.getElementById('${valueId}').textContent = parseFloat(this.value).toFixed(2)">
                            `;
                            focusGrid.appendChild(sliderDiv);
                        }
                    });
                    
                    focusSlidersDiv.appendChild(focusGrid);
                    
                    const focusWeightsEnabledCheckbox = document.getElementById('focusWeightsEnabled');
                    if (focusWeightsEnabledCheckbox) {
                        const saved = localStorage.getItem('focusWeightsEnabled_' + selectedClass);
                        if (saved !== null) focusWeightsEnabledCheckbox.checked = saved === 'true';
                        focusWeightsEnabledCheckbox.addEventListener('change', () => {
                            localStorage.setItem('focusWeightsEnabled_' + selectedClass, focusWeightsEnabledCheckbox.checked.toString());
                            if (!focusWeightsEnabledCheckbox.checked) {
                                setAllFocusSlidersTo(0);
                            } else restoreDefaultFocusWeights();
                        });
                    }
                    const focusWeightsSetZeroBtn = document.getElementById('focusWeightsSetZero');
                    if (focusWeightsSetZeroBtn) {
                        focusWeightsSetZeroBtn.addEventListener('click', () => {
                            setAllFocusSlidersTo(0);
                            if (focusWeightsEnabledCheckbox) focusWeightsEnabledCheckbox.checked = false;
                            localStorage.setItem('focusWeightsEnabled_' + selectedClass, 'false');
                        });
                    }
                    const focusWeightsRestoreBtn = document.getElementById('focusWeightsRestoreDefaults');
                    if (focusWeightsRestoreBtn) {
                        focusWeightsRestoreBtn.addEventListener('click', () => {
                            restoreDefaultFocusWeights();
                            if (focusWeightsEnabledCheckbox) focusWeightsEnabledCheckbox.checked = true;
                            localStorage.setItem('focusWeightsEnabled_' + selectedClass, 'true');
                        });
                    }
                }
            }
        }

        function updateSliderValue(statKey, value) {
            const val = parseFloat(value);
            document.getElementById(`value_${statKey}`).textContent = val.toFixed(2);
            
            // Build weights from current stat slider values so contribution sums to 100% as user drags
            const selectedClass = document.getElementById('weightClass')?.value;
            if (selectedClass) {
                const base = classWeights[selectedClass] || {};
                const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
                const weights = { ...base };
                statKeys.forEach(key => {
                    weights[key] = key === statKey ? val : (parseFloat(document.getElementById(`slider_${key}`)?.value) ?? base[key] ?? 0);
                });
                // Stats-only when user has no custom focus or focus all zero (match recalculateScores)
                const _cw = customWeights[selectedClass];
                const focusSum = (_cw?.focus && typeof _cw.focus === 'object') ? sumFocusWeights(_cw.focus) : -1;
                if ((focusSum === 0 || focusSum === -1) && (weights.hp_pct || weights.mana_pct || weights.ac_pct || weights.resists_pct)) {
                    weights.focus = {};
                }
                const focusMult = _cw?._meta?.focusMultiplier ?? 2.4;
                const normalized = normalizeWeights(weights, focusMult, selectedClass);
                
                statKeys.forEach(key => {
                    const contrib = (normalized[key] || 0) * 100;
                    const contribSpan = document.getElementById(`contrib_${key}`);
                    if (contribSpan) contribSpan.textContent = ` (${contrib.toFixed(1)}% contribution)`;
                });
                // Update summary line if present
                const statContribSum = statKeys.reduce((s, k) => s + (normalized[k] || 0), 0) * 100;
                const focusContribSum = (normalized.focusTarget || 0) * 100;
                const totalContrib = statContribSum + focusContribSum;
                const summaryEl = document.getElementById('weightContribSummary');
                if (summaryEl) {
                    summaryEl.textContent = focusContribSum > 0
                        ? `Contributions sum to ${totalContrib.toFixed(1)}% (Stats: ${statContribSum.toFixed(1)}%, Focus: ${focusContribSum.toFixed(1)}%)`
                        : `Contributions sum to ${totalContrib.toFixed(1)}% (Stats: 100% when all focus weights are 0)`;
                }
            }
        }

        function saveWeightValues() {
            const selectedClass = document.getElementById('weightClass')?.value;
            if (!selectedClass) return;

            if (!customWeights[selectedClass]) {
                customWeights[selectedClass] = {};
            }

            // ATK and Haste are now in focus weights, not stat weights
            const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
            statKeys.forEach(key => {
                const slider = document.getElementById(`slider_${key}`);
                if (slider) {
                    customWeights[selectedClass][key] = parseFloat(slider.value);
                }
            });

            // Save focus weights (use union of class + custom keys so 0-weight and custom keys are saved)
            const focusWeights = classWeights[selectedClass]?.focus || {};
            const customFocus = customWeights[selectedClass]?.focus || {};
            const allFocusKeys = [...new Set([...Object.keys(focusWeights), ...Object.keys(customFocus)])];
            if (!customWeights[selectedClass].focus) {
                customWeights[selectedClass].focus = {};
            }
            
            allFocusKeys.forEach(focusKey => {
                const focusValue = focusWeights[focusKey] ?? customFocus[focusKey];
                
                if (typeof focusValue === 'object' && focusValue !== null) {
                    // Nested object (e.g., Spell Damage with damage types)
                    if (!customWeights[selectedClass].focus[focusKey]) {
                        customWeights[selectedClass].focus[focusKey] = {};
                    }
                    const nestedKeys = [...new Set([...Object.keys(focusValue || {}), ...Object.keys(customWeights[selectedClass].focus[focusKey] || {})])];
                    nestedKeys.forEach(nestedKey => {
                        const sliderId = `slider_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                        const slider = document.getElementById(sliderId);
                        if (slider) {
                            customWeights[selectedClass].focus[focusKey][nestedKey] = parseFloat(slider.value);
                        }
                    });
                } else {
                    // Simple numeric value (including 0 so user can adjust up from zero)
                    const sliderId = `slider_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                    const slider = document.getElementById(sliderId);
                    if (slider) {
                        customWeights[selectedClass].focus[focusKey] = parseFloat(slider.value);
                    }
                }
            });

            saveCustomWeights();
        }

        function calculateResistScore(resistValue) {
            /**
             * Calculate resist score with progressive taper curve:
             * - L = 220 (start taper)
             * - H = 500 (hard-cap point)
             * - r = 0.35 (post-cap marginal credit)
             * - p = 1.2 (controls how "progressive" the taper is)
             * - t = (x - L) / (H - L) = (x - 220) / 280
             * 
             * S(x) = {
             *     x,                                    if x <= 220
             *     220 + (x - 220)(r + (1 - r)(1 - t)^p), if 220 < x < 500
             *     318 + r(x - 500),                      if x >= 500
             * }
             * 
             * Score percentage = (S(x) / S(500)) * 100, where S(500) = 318
             */
            if (resistValue <= 0) {
                return { score: 0.0, weight: 1.0 };
            }
            
            const L = 220.0;  // Start taper
            const H = 500.0;   // Hard-cap point
            const r = 0.35;    // Post-cap marginal credit
            const p = 1.2;     // Progressive taper control
            
            const x = parseFloat(resistValue);
            let S_x;
            
            if (x <= L) {
                // No taper: S(x) = x
                S_x = x;
            } else if (x < H) {
                // Progressive taper: S(x) = 220 + (x - 220)(r + (1 - r)(1 - t)^p)
                const t = (x - L) / (H - L);  // t = (x - 220) / 280
                S_x = L + (x - L) * (r + (1 - r) * Math.pow(1 - t, p));
            } else {
                // Post-cap: S(x) = 318 + r(x - 500)
                const S_500 = L + r * (H - L);  // = 220 + 0.35 * 280 = 318
                S_x = S_500 + r * (x - H);
            }
            
            // Normalize: S(500) = 318, so score percentage = (S(x) / 318) * 100
            // But cap at 100% to match HP/AC normalization
            const S_500 = L + r * (H - L);  // = 318
            const score = (S_500 > 0) ? Math.min((S_x / S_500) * 100.0, 100.0) : 0.0;
            
            // Weight is always 1.0
            const weight = 1.0;
            
            return { score: score, weight: weight };
        }

        const BARD_INSTRUMENT_CATS = ['Brass', 'Percussion', 'Singing', 'Strings', 'Wind'];

        /** Sum all numeric values in focus weights (including nested objects). */
        function sumFocusWeights(focusWeights) {
            if (!focusWeights || typeof focusWeights !== 'object') return 0;
            let sum = 0;
            for (const v of Object.values(focusWeights)) {
                if (typeof v === 'number') sum += v;
                else if (v && typeof v === 'object') sum += Object.values(v).reduce((a, b) => a + (typeof b === 'number' ? b : 0), 0);
            }
            return sum;
        }

        /** Target: stats = 65%, focus = 35%. Stat Total out of 65 pts, Focus Total out of 35. Works with dynamic reweighting. */
        const STAT_TARGET = 0.65;
        const FOCUS_TARGET = 0.35;

        /**
         * Normalize weights so stat weights sum to STAT_TARGET (0.65) and focus weights to FOCUS_TARGET (0.35).
         * Sliders act as relative weights within stats and within focus.
         */
        function normalizeWeights(weights, focusMultiplier = 2.4, charClass = null) {
            const hp = Math.max(0, parseFloat(weights.hp_pct) || 0);
            const mana = Math.max(0, parseFloat(weights.mana_pct) || 0);
            const ac = Math.max(0, parseFloat(weights.ac_pct) || 0);
            const resists = Math.max(0, parseFloat(weights.resists_pct) || 0);
            const focusMult = Math.max(0, parseFloat(focusMultiplier) || 0);
            const focusWeights = weights.focus || {};

            const statSum = hp + mana + ac + resists;
            const focusSubSum = sumFocusWeights(focusWeights);
            const focusSum = focusSubSum > 0 ? focusSubSum : focusMult;

            const normalized = {
                hp_pct: 0,
                mana_pct: 0,
                ac_pct: 0,
                resists_pct: 0,
                focusTarget: 0,
                atk_pct: 0,
                haste_pct: 0,
                focus: {}
            };

            if (statSum <= 0 && focusSubSum <= 0) return normalized;

            // When no focus is selected (all focus weights 0), stats get 100%. Otherwise 65% stats / 35% focus.
            // Use focusSubSum (actual focus weight sum), not focusSum, so that "all zeros except mana" gives 100% to mana.
            const statTarget = focusSubSum > 0 ? STAT_TARGET : 1.0;
            const focusTarget = focusSubSum > 0 ? FOCUS_TARGET : 0;

            if (statSum > 0) {
                const statScale = statTarget / statSum;
                normalized.hp_pct = hp * statScale;
                normalized.mana_pct = mana * statScale;
                normalized.ac_pct = ac * statScale;
                normalized.resists_pct = resists * statScale;
            }
            if (focusSubSum > 0) {
                normalized.focusTarget = focusTarget;
                const focusScale = focusTarget / (focusSubSum > 0 ? focusSubSum : (focusMult || 1));
                if (focusSubSum > 0) {
                    for (const [focusCat, focusValue] of Object.entries(focusWeights)) {
                        if (focusCat === 'ATK' || focusCat === 'Haste') {
                            const v = typeof focusValue === 'number' ? focusValue : 0;
                            if (v > 0) normalized.focus[focusCat] = v * focusScale;
                        } else if (typeof focusValue === 'object' && focusValue !== null) {
                            const innerSum = Object.values(focusValue).reduce((a, b) => a + (typeof b === 'number' ? b : 0), 0);
                            if (innerSum > 0) {
                                normalized.focus[focusCat] = {};
                                for (const [k, v] of Object.entries(focusValue)) {
                                    if (typeof v === 'number' && v > 0) {
                                        normalized.focus[focusCat][k] = (v / focusSubSum) * focusTarget;
                                    }
                                }
                            }
                        } else if (typeof focusValue === 'number' && focusValue > 0) {
                            normalized.focus[focusCat] = focusValue * focusScale;
                        }
                    }
                } else {
                    if (focusWeights['ATK']) normalized.focus['ATK'] = focusTarget * (parseFloat(focusWeights['ATK']) || 0) / (focusMult || 1);
                    if (focusWeights['Haste']) normalized.focus['Haste'] = focusTarget * (parseFloat(focusWeights['Haste']) || 0) / (focusMult || 1);
                    if (focusWeights['FT']) normalized.focus['FT'] = focusTarget * (parseFloat(focusWeights['FT']) || 0) / (focusMult || 1);
                }
            }

            return normalized;
        }

        function recalculateScores() {
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass || !classWeights[charClass]) return;

                const customWeight = customWeights[charClass] || {};
                const focusMultiplier = customWeight._meta?.focusMultiplier || 2.4;
                
                let weights = JSON.parse(JSON.stringify(originalClassWeights[charClass] || classWeights[charClass]));
                
                // Apply custom stat weights (ensure stat keys exist so e.g. "mana only" is applied even if backend omitted a key)
                const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
                statKeys.forEach(k => {
                    if (customWeight[k] !== undefined) {
                        weights[k] = customWeight[k];
                    }
                });
                Object.keys(customWeight).forEach(key => {
                    if (key !== '_meta' && key !== 'focus' && !statKeys.includes(key) && weights.hasOwnProperty(key)) {
                        weights[key] = customWeight[key];
                    }
                });
                
                // Apply custom focus weights
                if (customWeight.focus && weights.focus) {
                    Object.keys(customWeight.focus).forEach(focusKey => {
                        if (weights.focus[focusKey] !== undefined) {
                            if (typeof customWeight.focus[focusKey] === 'object' && customWeight.focus[focusKey] !== null) {
                                // Nested object
                                if (!weights.focus[focusKey]) {
                                    weights.focus[focusKey] = {};
                                }
                                Object.keys(customWeight.focus[focusKey]).forEach(nestedKey => {
                                    if (weights.focus[focusKey][nestedKey] !== undefined) {
                                        weights.focus[focusKey][nestedKey] = customWeight.focus[focusKey][nestedKey];
                                    }
                                });
                            } else {
                                // Simple value
                                weights.focus[focusKey] = customWeight.focus[focusKey];
                            }
                        }
                    });
                }
                // When user set all focus to 0, or never customized focus (stats-only custom), give 100% to stats
                const hasCustomStat = statKeys.some(k => customWeight[k] !== undefined);
                const customFocusSum = (customWeight.focus && typeof customWeight.focus === 'object') ? sumFocusWeights(customWeight.focus) : -1;
                if (hasCustomStat && (customFocusSum === 0 || customFocusSum === -1) && (weights.hp_pct || weights.mana_pct || weights.ac_pct || weights.resists_pct)) {
                    weights.focus = {};
                }

                // Use backend-normalized weights when no custom weights (focus ~35%, FT in focus)
                let normalized;
                const hasCustom = customWeight && Object.keys(customWeight).filter(k => k !== '_meta').length > 0;
                if (!hasCustom && normalizedClassWeights[charClass]) {
                    normalized = normalizedClassWeights[charClass];
                } else {
                    normalized = normalizeWeights(weights, focusMultiplier, charClass);
                }
                const scores = char.scores || {};
                let statPoints = 0.0;
                let focusPoints = 0.0;

                if (scores.hp_pct !== undefined && normalized.hp_pct > 0) {
                    const pts = scores.hp_pct * normalized.hp_pct;
                    statPoints += pts;
                }
                if (scores.mana_pct !== undefined && normalized.mana_pct > 0) {
                    const pts = scores.mana_pct * normalized.mana_pct;
                    statPoints += pts;
                }
                if (scores.ac_pct !== undefined && normalized.ac_pct > 0) {
                    const pts = scores.ac_pct * normalized.ac_pct;
                    statPoints += pts;
                }
                if (scores.resists_pct !== undefined && normalized.resists_pct > 0) {
                    if (advancedResists && char.individual_resists) {
                        const resistTypes = ['MR', 'FR', 'CR', 'DR', 'PR'];
                        const numResists = resistTypes.filter(rt => char.individual_resists[rt] !== undefined && char.individual_resists[rt] > 0).length || 5;
                        const resistWeightPerResist = normalized.resists_pct / numResists;
                        let totalResistScore = 0.0;
                        let totalResistWeight = 0.0;
                        resistTypes.forEach(resistType => {
                            const resistValue = char.individual_resists[resistType] || 0;
                            if (resistValue > 0) {
                                const { score, weight: curveWeight } = calculateResistScore(resistValue);
                                const effectiveWeight = resistWeightPerResist * curveWeight;
                                totalResistScore += score * effectiveWeight;
                                totalResistWeight += effectiveWeight;
                            }
                        });
                        if (totalResistWeight > 0) {
                            const avgResistScore = totalResistScore / totalResistWeight;
                            statPoints += avgResistScore * normalized.resists_pct;
                        }
                    } else {
                        statPoints += scores.resists_pct * normalized.resists_pct;
                    }
                }

                const focusWeights = normalized.focus || {};
                if (scores.atk_pct !== undefined) {
                    const w = focusWeights['ATK'] || 0;
                    if (w > 0) focusPoints += scores.atk_pct * w;
                }
                if (scores.haste_pct !== undefined) {
                    const w = focusWeights['Haste'] || 0;
                    if (w > 0) focusPoints += scores.haste_pct * w;
                }
                const ftWeight = focusWeights['FT'] || 0;
                if (ftWeight > 0 && (scores.ft_capped !== undefined || scores.ft_current !== undefined)) {
                    const ftPct = scores.ft_capped ? 100 : (scores.ft_pct != null ? scores.ft_pct : 0);
                    focusPoints += ftPct * ftWeight;
                }
                const focusScores = scores.focus_scores || {};
                if (charClass === 'Warrior') {
                    for (const [focusCat, weight] of Object.entries(focusWeights)) {
                        if (focusCat === 'ATK') continue;
                        if (['Darkblade', 'Raex Chest', 'Haste'].includes(focusCat) && typeof weight === 'number' && weight > 0) {
                            focusPoints += (focusScores[focusCat] || 0) * weight;
                        }
                    }
                } else if (Object.keys(focusWeights).length > 0 && scores.focus_overall_pct !== undefined) {
                    let totalFocusWeight = 0.0;
                    for (const [focusCat, weight] of Object.entries(focusWeights)) {
                        if (focusCat === 'ATK' || focusCat === 'Haste') continue;
                        if (typeof weight === 'object') totalFocusWeight += Object.values(weight).reduce((a, b) => a + b, 0);
                        else totalFocusWeight += weight;
                    }
                    if (totalFocusWeight > 0) focusPoints += scores.focus_overall_pct * totalFocusWeight;
                }

                char.stat_points = statPoints;
                char.focus_points = focusPoints;
                char.total_points = statPoints + focusPoints;
            });

            // Find maximum total points per class for normalization
            // Do this AFTER all characters have been processed
            const maxPointsByClass = {};
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass) return;
                const totalPts = char.total_points || 0;
                if (totalPts > 0 && (!maxPointsByClass[charClass] || totalPts > maxPointsByClass[charClass])) {
                    maxPointsByClass[charClass] = totalPts;
                }
            });
            
            // Normalize overall_score by class maximum (as percentage of max points)
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass || !maxPointsByClass[charClass] || maxPointsByClass[charClass] === 0) {
                    char.overall_score = 0;
                } else {
                    // overall_score is now percentage of max points for this class
                    const totalPts = char.total_points || 0;
                    char.overall_score = (totalPts / maxPointsByClass[charClass]) * 100.0;
                }
            });
            
            // Normalized score = % of class max (class-best = 100). Used for overall ranking so #1 per class ties.
            characters.forEach(char => {
                const totalPts = char.total_points || 0;
                const classMax = maxPointsByClass[char.class];
                char.normalized_score = (classMax > 0 && totalPts > 0) ? (totalPts / classMax) * 100 : 0;
            });

            // Sort by normalized score (desc) for overall ranking — class #1s all have 100 and tie for #1
            characters.sort((a, b) => {
                const scoreA = a.normalized_score || 0;
                const scoreB = b.normalized_score || 0;
                if (Math.abs(scoreB - scoreA) < 0.001) return (a.name || '').localeCompare(b.name || '');
                return scoreB - scoreA;
            });

            // Assign overall rank with ties (same score to 2 decimals = same rank)
            const scoreTo2 = (s) => Math.round((s || 0) * 100) / 100;
            let rank = 1;
            for (let i = 0; i < characters.length; i++) {
                if (i > 0 && scoreTo2(characters[i].normalized_score) < scoreTo2(characters[i - 1].normalized_score)) {
                    rank = i + 1;
                }
                characters[i].overall_rank = rank;
            }

            // Class ranks: group by class, sort by total_points desc, assign ranks with ties
            const charactersByClass = {};
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass) return;
                if (!charactersByClass[charClass]) charactersByClass[charClass] = [];
                charactersByClass[charClass].push(char);
            });
            Object.keys(charactersByClass).forEach(charClass => {
                const classChars = charactersByClass[charClass];
                classChars.sort((a, b) => {
                    const sa = a.total_points || 0;
                    const sb = b.total_points || 0;
                    if (Math.abs(sb - sa) < 0.001) return (a.name || '').localeCompare(b.name || '');
                    return sb - sa;
                });
                let classRank = 1;
                for (let i = 0; i < classChars.length; i++) {
                    if (i > 0 && scoreTo2(classChars[i].total_points) < scoreTo2(classChars[i - 1].total_points)) {
                        classRank = i + 1;
                    }
                    classChars[i].class_rank = classRank;
                }
            });
        }
        
        async function loadData() {
            try {
                // Try multiple possible paths for GitHub Pages
                const possiblePaths = [
                    'class_rankings.json',  // Same directory
                    './class_rankings.json',  // Explicit same directory
                    '/class_rankings.json',  // Root path
                    window.location.pathname.replace(/\/[^/]*$/, '/') + 'class_rankings.json',  // Same directory as HTML
                ];
                
                // Add repository path if on GitHub Pages
                const repoMatch = window.location.pathname.match(/^\/[^/]+\/[^/]+/);
                if (repoMatch) {
                    possiblePaths.push(repoMatch[0] + '/class_rankings.json');
                }
                
                let jsonPath = '';
                let response = null;
                let lastError = null;
                
                for (const path of possiblePaths) {
                    try {
                        console.log(`Trying to load from: ${path}`);
                        response = await fetch(path);
                        if (response.ok) {
                            jsonPath = path;
                            console.log(`✓ Successfully loaded from: ${path}`);
                            break;
                        } else {
                            console.log(`✗ Failed to load from ${path}: ${response.status}`);
                            lastError = `HTTP ${response.status} from ${path}`;
                        }
                    } catch (e) {
                        console.log(`✗ Error loading from ${path}:`, e.message);
                        lastError = e.message;
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error(`Could not load class_rankings.json from any path. Last error: ${lastError}. Tried: ${possiblePaths.join(', ')}`);
                }
                
                const data = await response.json();
                console.log('Loaded data, parsing...', Object.keys(data));
                
                // Handle both old format (array) and new format (object with characters)
                if (Array.isArray(data)) {
                    characters = data;
                    console.log(`Loaded ${characters.length} characters (array format)`);
                } else {
                    characters = data.characters || [];
                    classWeights = data.class_weights || {};
                    normalizedClassWeights = data.normalized_class_weights || {};
                    originalClassWeights = JSON.parse(JSON.stringify(classWeights)); // Deep copy
                    focusCandidates = data.focus_candidates || {};
                    console.log(`Loaded ${characters.length} characters, ${Object.keys(classWeights).length} class weights`);
                }
                filteredCharacters = [...characters];
                
                // Load custom weights from localStorage
                console.log('Loading custom weights...');
                loadCustomWeights();
                
                // Recompute overall_score and class_rank from the same formula used in the detail panel
                // (total_points / class max). This keeps ranking consistent with "Overall Total" points.
                console.log('Recalculating scores for consistent ranking...');
                recalculateScores();
                
                console.log('Populating filters...');
                populateFilters();
                console.log('Setting up weight controls...');
                setupWeightControls();
                console.log('Rendering table...');
                filterAndSort();  // Sort by recalculated overall_score so rank matches displayed points
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('rankingsTable').style.display = 'table';
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                console.error('Error:', error);
            }
        }

        function populateFilters() {
            const classes = new Set(characters.map(c => c.class).filter(c => c));
            const classSelect = document.getElementById('filterClass');
            
            [...classes].sort().forEach(cls => {
                const option = document.createElement('option');
                option.value = cls;
                option.textContent = cls;
                classSelect.appendChild(option);
            });
        }

        function filterAndSort() {
            const search = (nameSearch || '').trim().toLowerCase();
            filteredCharacters = characters.filter(char => {
                if (filterClass && char.class !== filterClass) return false;
                if (search && !(char.name || '').toLowerCase().includes(search)) return false;
                return true;
            });
            
            filteredCharacters.sort((a, b) => {
                if (sortBy === 'overall') return b.overall_score - a.overall_score;
                if (sortBy === 'class_rank') {
                    if (a.class !== b.class) return a.class.localeCompare(b.class);
                    return a.class_rank - b.class_rank;
                }
                if (sortBy === 'hp') return (b.stats.hp || 0) - (a.stats.hp || 0);
                if (sortBy === 'mana') return (b.stats.mana || 0) - (a.stats.mana || 0);
                if (sortBy === 'ac') return (b.stats.ac || 0) - (a.stats.ac || 0);
                if (sortBy === 'atk') {
                    const aAtk = parseInt(a.stats.atk_item?.split(' / ')[0] || '0');
                    const bAtk = parseInt(b.stats.atk_item?.split(' / ')[0] || '0');
                    return bAtk - aAtk;
                }
                if (sortBy === 'resists') return (b.scores.resists || 0) - (a.scores.resists || 0);
                if (sortBy === 'focus') return (b.scores.focus_overall_pct || 0) - (a.scores.focus_overall_pct || 0);
                return 0;
            });
            
            renderTable();
        }

        function getScoreClass(score) {
            if (score >= 90) return 'high';
            if (score >= 70) return 'medium';
            return 'low';
        }

        function formatScore(score) {
            if (score === null || score === undefined) return 'N/A';
            if (typeof score !== 'number') return String(score);
            if (isNaN(score)) return 'N/A';
            return score.toFixed(1) + '%';
        }

        function renderTable() {
            const tbody = document.getElementById('rankingsBody');
            tbody.innerHTML = '';
            
            filteredCharacters.forEach((char, index) => {
                const row = document.createElement('tr');
                const scores = char.scores;
                const focii = char.focii || {};
                
                // Get spell damage score (class-specific)
                const spellDmgScore = scores.focus_scores && scores.focus_scores['Spell Damage'] 
                    ? scores.focus_scores['Spell Damage'] 
                    : null;
                
                // Get class-specific weight configuration
                const charClass = char.class || '';
                const classWeightConfig = classWeights[charClass] || {};
                const focusWeights = classWeightConfig.focus || {};
                const spellDamageWeights = focusWeights['Spell Damage'] || {};
                
                // Special handling for Warriors and Pal/SK - show focus items status
                let damageBadges = '';
                let otherBadges = '';
                
                if (charClass === 'Warrior') {
                    // For Warriors, show individual focus items in Damage Types column
                    const focusItems = scores.focus_items || {};
                    const badges = [];
                    if (focusItems.has_darkblade) {
                        badges.push('<span class="focus-badge" title="Darkblade of the Warlord">Darkblade</span>');
                    }
                    if (focusItems.has_raex_chest) {
                        badges.push('<span class="focus-badge" title="Raex\'s Chestplate of Destruction">Raex Chest</span>');
                    }
                    if (focusItems.has_haste) {
                        badges.push('<span class="focus-badge" title="Max Haste (100%)">Haste ✓</span>');
                    }
                    damageBadges = badges.length > 0 ? badges.join(' ') : '<span style="color: #6c757d;">-</span>';
                    otherBadges = '<span style="color: #6c757d;">-</span>'; // Warriors don't have other focii
                } else if (charClass === 'Paladin' || charClass === 'Shadow Knight') {
                    // For Pal/SK, show Shield of Strife
                    const focusItems = scores.focus_items || {};
                    if (focusItems.has_shield) {
                        damageBadges = '<span class="focus-badge" title="Shield of Strife">Shield of Strife ✓</span>';
                    } else {
                        damageBadges = '<span class="focus-badge" style="opacity: 0.3;">No Shield</span>';
                    }
                    otherBadges = ''; // Pal/SK don't have other focii
                } else {
                    // Check if this is a pure melee class (no caster focuses)
                    const pureMeleeClasses = ['Warrior', 'Monk', 'Rogue'];
                    const isPureMelee = pureMeleeClasses.includes(charClass);
                    
                    if (isPureMelee) {
                        // Pure melees don't have caster focuses
                        damageBadges = '<span style="color: #6c757d;">-</span>';
                        otherBadges = '<span style="color: #6c757d;">-</span>';
                    } else {
                        // Get damage-specific focii - only show damage types that are scored for this class
                        const damageFocii = char.damage_focii || {};
                        const allDamageFocii = Object.entries(damageFocii)
                            .filter(([type]) => (spellDamageWeights[type] || 0) > 0)
                            .sort((a, b) => (spellDamageWeights[b[0]] || 0) - (spellDamageWeights[a[0]] || 0));
                        
                        damageBadges = allDamageFocii
                            .map(([type, pct]) => {
                                const weight = spellDamageWeights[type] || 0;
                                const title = `${type} Damage: ${pct}% (weighted: ${weight})`;
                                return `<span class="focus-badge" title="${title}">${type} ${pct}%</span>`;
                            }).join('');
                        
                        // Only show focuses that the current priority list has as scored stats; sort by max contribution (weight) desc
                        const focusDisplay = [];
                    
                    // Helper: returns html for a focus badge (all shown items are scored)
                    const formatFocusWithCategory = (baseName, category, pct, weight) => {
                        const catAbbrev = { 'Det': 'Det', 'Bene': 'Bene', 'Nuke': '', 'Sanguine': 'Sanguine', 'All': 'All' }[category] || '';
                        let displayName = catAbbrev ? `${catAbbrev} ${baseName}` : baseName;
                        const title = `${baseName} (${category}): ${pct}% (weighted: ${weight})`;
                        return `<span class="focus-badge" title="${title}">${displayName} ${pct}%</span>`;
                    };
                    
                    if (focii['Spell Mana Efficiency'] > 0 && getFocusWeight('Spell Mana Efficiency', focusWeights) > 0) {
                        const manaEffCats = char.mana_efficiency_cats || {};
                        const weight = getFocusWeight('Spell Mana Efficiency', focusWeights);
                        Object.entries(manaEffCats).forEach(([cat, pct]) => {
                            if (cat === 'Sanguine') return;
                            focusDisplay.push({ weight, html: formatFocusWithCategory('Mana Efficiency', cat, pct, weight) });
                        });
                    }
                    
                    if (focii['Spell Haste'] > 0) {
                        const hasteCats = char.spell_haste_cats || {};
                        Object.entries(hasteCats).forEach(([cat, pct]) => {
                            const hasteWeightKey = cat === 'Bene' ? 'Beneficial Spell Haste' : 'Detrimental Spell Haste';
                            const weight = focusWeights[hasteWeightKey] || 0;
                            if (weight <= 0) return;
                            focusDisplay.push({ weight, html: formatFocusWithCategory('Spell Haste', cat, pct, weight) });
                        });
                    }
                    
                    if (focii['Buff Spell Duration'] > 0 && getFocusWeight('Buff Spell Duration', focusWeights) > 0) {
                        const durCats = char.duration_cats || {};
                        const weight = getFocusWeight('Buff Spell Duration', focusWeights);
                        ['Bene', 'All'].forEach(cat => {
                            if (durCats[cat] !== undefined && durCats[cat] > 0) {
                                focusDisplay.push({ weight, html: formatFocusWithCategory('Duration', cat === 'All' ? 'All' : 'Bene', durCats[cat], weight) });
                            }
                        });
                    }
                    if (focii['Detrimental Spell Duration'] > 0 && getFocusWeight('Detrimental Spell Duration', focusWeights) > 0) {
                        const durCats = char.duration_cats || {};
                        const weight = getFocusWeight('Detrimental Spell Duration', focusWeights);
                        ['Det', 'All'].forEach(cat => {
                            if (durCats[cat] !== undefined && durCats[cat] > 0) {
                                focusDisplay.push({ weight, html: formatFocusWithCategory('Duration', cat === 'All' ? 'All' : 'Det', durCats[cat], weight) });
                            }
                        });
                    }
                    if (focii['All Spell Duration'] > 0 && getFocusWeight('All Spell Duration', focusWeights) > 0) {
                        const durCats = char.duration_cats || {};
                        if (durCats['All'] !== undefined && durCats['All'] > 0) {
                            const weight = getFocusWeight('All Spell Duration', focusWeights);
                            focusDisplay.push({ weight, html: formatFocusWithCategory('Duration', 'All', durCats['All'], weight) });
                        }
                    }
                    
                    Object.entries(focii)
                        .filter(([cat]) => !['Spell Damage', 'Spell Mana Efficiency', 'Spell Haste', 
                                             'Buff Spell Duration', 'Detrimental Spell Duration', 'All Spell Duration'].includes(cat))
                        .filter(([cat]) => getFocusWeight(cat, focusWeights) > 0)
                        .forEach(([cat, pct]) => {
                            const weight = getFocusWeight(cat, focusWeights);
                            let shortName = cat.replace('Spell ', '');
                            if (shortName === 'Healing Enhancement') shortName = 'Healing';
                            else if (shortName === 'Spell Range Extension') shortName = 'Range Ext';
                            focusDisplay.push({ weight, html: `<span class="focus-badge" title="${cat}: ${pct}% (weighted: ${weight})">${shortName} ${pct}%</span>` });
                        });
                    
                    focusDisplay.sort((a, b) => b.weight - a.weight);
                    otherBadges = focusDisplay.length > 0 ? focusDisplay.map(x => x.html).join(', ') : '<span style="color: #6c757d;">-</span>';
                    }
                }
                
                // Format actual stat values
                const formatStat = (value, statName) => {
                    if (value === null || value === undefined) {
                        if (statName === 'ac') return '0';  // AC defaults to 0 if missing
                        return 'N/A';
                    }
                    if (statName === 'haste') {
                        // Haste is binary: show "100% ✓" if max (30% item = 100% total), otherwise actual item value
                        // Get haste_value from scores, not from the value parameter
                        const hasteValue = scores.haste_value;
                        if (hasteValue === null || hasteValue === undefined) return 'N/A';
                        // Check if it's actually a number, not a string like "255 / 250"
                        if (typeof hasteValue === 'number') {
                            return hasteValue >= 30 ? '100% ✓' : `${hasteValue}%`;
                        }
                        return 'N/A';
                    }
                    if (statName === 'atk') {
                        // ATK shows as "current / 250"
                        if (typeof value === 'string' && value.includes(' / ')) {
                            return value;
                        }
                        return value || '0 / 250';
                    }
                    if (statName === 'ac') {
                        // AC - ensure we convert to number and format properly
                        const acValue = typeof value === 'number' ? value : parseInt(value) || 0;
                        return acValue.toLocaleString();
                    }
                    // For other stats, convert to number if needed and format
                    const numValue = typeof value === 'number' ? value : (parseInt(value) || 0);
                    return numValue.toLocaleString();
                };
                
                // Build row cells in exact order matching headers
                const cells = [];
                
                // Rank, Class Rank, Name, Guild, Class, Overall (fixed columns - indices 0-5)
                // When filtering by class, show rank as position in this list (1,2,3...) so "sort by mana" shows correct order
                const rankDisplay = (filterClass && sortBy === 'overall') ? (index + 1) : (char.overall_rank || index + 1);
                cells.push(`<td class="rank">#${rankDisplay}</td>`);
                cells.push(`<td class="rank">#${char.class_rank || '-'}</td>`);
                cells.push(`<td class="name"><a href="https://www.takproject.net/magelo/character.php?char=${encodeURIComponent(char.name)}" target="_blank">${escapeHtml(char.name)}</a></td>`);
                cells.push(`<td>${escapeHtml(char.guild || '')}</td>`);
                cells.push(`<td>${escapeHtml(char.class || '')}</td>`);
                cells.push(`<td class="score ${getScoreClass(char.overall_score)}">${formatScore(char.overall_score)}</td>`);
                
                // Stat columns (in header order - indices 6-10)
                // Index 6: HP
                cells.push(`<td class="stat-col" data-stat="hp">${formatStat(char.stats.hp, 'hp')}</td>`);
                // Index 7: Mana
                cells.push(`<td class="stat-col" data-stat="mana">${formatStat(char.stats.mana, 'mana')}</td>`);
                // Index 8: AC - check both stats.ac and scores.ac, ensure it's a number
                const acValue = (char.stats.ac !== undefined && char.stats.ac !== null) 
                    ? (typeof char.stats.ac === 'number' ? char.stats.ac : parseInt(char.stats.ac) || 0)
                    : ((scores.ac !== undefined && scores.ac !== null) 
                        ? (typeof scores.ac === 'number' ? scores.ac : parseInt(scores.ac) || 0)
                        : 0);
                cells.push(`<td class="stat-col" data-stat="ac">${acValue.toLocaleString()}</td>`);
                // Index 9: ATK
                cells.push(`<td class="stat-col" data-stat="atk">${formatStat(char.stats.atk_item, 'atk')}</td>`);
                // Index 10: Resists - total resists value
                const resistsValue = scores.resists !== null && scores.resists !== undefined ? scores.resists : 0;
                const resistsDisplay = resistsValue > 0 ? resistsValue.toLocaleString() : 'N/A';
                cells.push(`<td class="stat-col" data-stat="resists">${resistsDisplay}</td>`);
                
                // Focus %, Spell Dmg %, Damage Types, Other Focii (fixed columns - indices 11-14)
                // IMPORTANT: Always create all 15 cells in exact header order to maintain alignment
                cells.push(`<td class="score">${formatScore(scores.focus_overall_pct)}</td>`);  // Index 11: Focus %
                cells.push(`<td class="stat-col score ${spellDmgScore !== null ? getScoreClass(spellDmgScore) : ''}" data-stat="spelldmg">${formatScore(spellDmgScore)}</td>`);  // Index 12: Spell Dmg %
                // Damage Types - ensure we're using the badges, not a score
                const damageTypesDisplay = damageBadges || '<span style="color: #6c757d;">-</span>';
                cells.push(`<td>${damageTypesDisplay}</td>`);  // Index 13: Damage Types
                // Other Focii - ensure we're using the badges, not a score
                const otherFociiDisplay = otherBadges || '<span style="color: #6c757d;">-</span>';
                cells.push(`<td>${otherFociiDisplay}</td>`);  // Index 14: Other Focii
                
                // Verify we have exactly 15 cells (matching 15 headers)
                if (cells.length !== 15) {
                    console.error(`Row for ${char.name} has ${cells.length} cells, expected 15`);
                    console.error('Cells:', cells.map((c, i) => `${i}: ${c.substring(0, 50)}`));
                }
                
                // Debug: Log first few rows to verify column alignment
                if (index < 3) {
                    console.log(`Row ${index} (${char.name}):`, {
                        ac: acValue,
                        haste: scores.haste_value,
                        damageBadges: damageBadges.substring(0, 50),
                        otherBadges: otherBadges.substring(0, 50),
                        cellCount: cells.length
                    });
                }
                
                row.innerHTML = cells.join('');
                row.classList.add('clickable-row');
                row.addEventListener('click', (e) => {
                    // Don't trigger if clicking directly on a link
                    // But allow clicks on badges and other elements to trigger the modal
                    const target = e.target;
                    const isDirectLink = target.tagName === 'A';
                    if (!isDirectLink) {
                        // Check if we're inside a link (e.g., character name link)
                        const linkParent = target.closest('a');
                        if (!linkParent) {
                            // Not clicking on a link, show the modal
                            showScoreBreakdown(char);
                        }
                    }
                });
                
                tbody.appendChild(row);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.getElementById('filterClass').addEventListener('change', (e) => {
            filterClass = e.target.value;
            filterAndSort();
        });

        document.getElementById('searchName').addEventListener('input', (e) => {
            nameSearch = e.target.value;
            filterAndSort();
        });

        document.getElementById('sortBy').addEventListener('change', (e) => {
            sortBy = e.target.value;
            filterAndSort();
        });

        // Modal functionality
        const modal = document.getElementById('scoreModal');
        const closeBtn = document.getElementsByClassName('close')[0];

        closeBtn.onclick = function() {
            modal.style.display = 'none';
        };

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };

        function showScoreBreakdown(char) {
            const modal = document.getElementById('scoreModal');
            const modalContent = document.getElementById('modalContent');
            const scores = char.scores || {};
            
            // Get the same weights used in recalculateScores (including custom weights)
            const charClass = char.class;
            const customWeight = customWeights[charClass] || {};
            const focusMultiplier = customWeight._meta?.focusMultiplier || 2.4;
            
            let weights = JSON.parse(JSON.stringify(originalClassWeights[charClass] || classWeights[charClass] || {}));
            
            // Apply custom weights (same logic as recalculateScores)
            Object.keys(customWeight).forEach(key => {
                if (key !== '_meta' && key !== 'focus' && weights.hasOwnProperty(key)) {
                    weights[key] = customWeight[key];
                }
            });
            
            // Apply custom focus weights
            if (customWeight.focus && weights.focus) {
                Object.keys(customWeight.focus).forEach(focusKey => {
                    if (weights.focus[focusKey] !== undefined) {
                        if (typeof customWeight.focus[focusKey] === 'object' && customWeight.focus[focusKey] !== null) {
                            if (!weights.focus[focusKey]) {
                                weights.focus[focusKey] = {};
                            }
                            Object.keys(customWeight.focus[focusKey]).forEach(nestedKey => {
                                if (weights.focus[focusKey][nestedKey] !== undefined) {
                                    weights.focus[focusKey][nestedKey] = customWeight.focus[focusKey][nestedKey];
                                }
                            });
                        } else {
                            weights.focus[focusKey] = customWeight.focus[focusKey];
                        }
                    }
                });
            }
            
            // Use backend-normalized weights when no custom (keeps focus ~35%, ft_half for SHD/PAL/RNG/BST); else same as recalculateScores
            let normalized;
            const hasCustom = customWeight && Object.keys(customWeight).filter(k => k !== '_meta').length > 0;
            if (!hasCustom && normalizedClassWeights[charClass]) {
                normalized = normalizedClassWeights[charClass];
            } else {
                normalized = normalizeWeights(weights, focusMultiplier, char.class);
            }
            const classWeightConfig = (hasCustom || !normalizedClassWeights[charClass]) ? weights : normalized; // Display: normalized when from backend
            const focusWeights = normalized.focus || {};
            
            let html = `<h2>${escapeHtml(char.name)} (${escapeHtml(char.class)})</h2>`;
            html += `<p><a href="https://www.takproject.net/magelo/character.php?char=${encodeURIComponent(char.name)}" target="_blank">View on Magelo</a></p>`;
            html += `<div class="score-breakdown">`;
            
            // Use browser-computed points when available (from recalculateScores; works with dynamic reweighting)
            let totalStatPoints = 0.0;
            let totalFocusPoints = 0.0;
            const totalPoints = (char.total_points !== undefined && char.total_points > 0) ? char.total_points : 1;
            const useComputedPoints = (char.stat_points !== undefined && char.focus_points !== undefined);
            
            html += `<h3>Overall Score: ${formatScore(char.overall_score)}%</h3>`;
            
            // Stat Scores
            html += `<h3>Stat Scores</h3>`;
            html += `<table><thead><tr><th>Stat</th><th>Value</th><th>Score %</th><th>Weight</th><th>Points</th><th>% of total</th></tr></thead><tbody>`;
            
            // HP - use normalized weight for calculation, but show raw weight for display
            if (scores.hp_pct !== undefined && normalized.hp_pct > 0) {
                const normalizedWeight = normalized.hp_pct;  // For calculation (0.20 = 20% contribution)
                const rawWeight = weights.hp_pct || 1.0;  // Raw weight for display (1.0 = 20% target)
                const hpValue = char.stats.hp || 0;
                const hpPct = scores.hp_pct;
                const points = hpPct * normalizedWeight;  // Use normalized for calculation
                totalStatPoints += points;
                const hpPctOfTotal = (points / totalPoints * 100).toFixed(1);
                html += `<tr><td>HP</td><td>${hpValue.toLocaleString()}</td><td>${formatScore(hpPct)}</td><td>${rawWeight.toFixed(2)}</td><td>${points.toFixed(2)}</td><td>${hpPctOfTotal}%</td></tr>`;
            }
            
            // Mana - use normalized weight for calculation, but show raw weight for display
            if (scores.mana_pct !== undefined && normalized.mana_pct > 0) {
                const normalizedWeight = normalized.mana_pct;  // For calculation
                const rawWeight = weights.mana_pct || 0.0;  // Raw weight for display
                const manaValue = char.stats.mana || 0;
                const manaPct = scores.mana_pct;
                const points = manaPct * normalizedWeight;  // Use normalized for calculation
                totalStatPoints += points;
                const manaPctOfTotal = (points / totalPoints * 100).toFixed(1);
                html += `<tr><td>Mana</td><td>${manaValue.toLocaleString()}</td><td>${formatScore(manaPct)}</td><td>${rawWeight.toFixed(2)}</td><td>${points.toFixed(2)}</td><td>${manaPctOfTotal}%</td></tr>`;
            }
            
            // AC - use normalized weight for calculation, but show raw weight for display
            if (scores.ac_pct !== undefined && normalized.ac_pct > 0) {
                const normalizedWeight = normalized.ac_pct;  // For calculation
                const rawWeight = weights.ac_pct || 0.0;  // Raw weight for display
                const acValue = char.stats.ac || 0;
                const acPct = scores.ac_pct;
                const points = acPct * normalizedWeight;  // Use normalized for calculation
                totalStatPoints += points;
                const acPctOfTotal = (points / totalPoints * 100).toFixed(1);
                html += `<tr><td>AC</td><td>${acValue.toLocaleString()}</td><td>${formatScore(acPct)}</td><td>${rawWeight.toFixed(2)}</td><td>${points.toFixed(2)}</td><td>${acPctOfTotal}%</td></tr>`;
            }
            
            // ATK is now in Focus Scores, not Stat Scores - skip it here
            
            // Resists - show individual resists if available and advanced mode is on
            if (scores.resists !== undefined && scores.resists !== null || scores.resists_pct !== undefined) {
                const normalizedResistWeight = normalized.resists_pct;  // For calculation
                const rawResistWeight = weights.resists_pct || 1.0;  // Raw weight for display (1.0 = 17.5% target)
                const resistsValue = scores.resists !== undefined && scores.resists !== null ? scores.resists : 0;
                
                // Show individual resists if available
                const individualResistScores = scores.individual_resist_scores;
                const charIndividualResists = char.individual_resists || {};
                
                if (individualResistScores && Object.keys(individualResistScores).length > 0 && advancedResists) {
                    html += `<tr><td colspan="6"><strong>Resists (Advanced)</strong></td></tr>`;
                    const resistTypes = ['MR', 'FR', 'CR', 'DR', 'PR'];
                    const numResists = resistTypes.filter(rt => individualResistScores[rt] && individualResistScores[rt].value > 0).length || 5;
                    const resistWeightPerResist = normalizedResistWeight / numResists;  // Total normalized weight divided by number of resists
                    let totalRawValue = 0;
                    let totalAdvancedPoints = 0;
                    let totalResistScore = 0;
                    let totalResistWeight = 0;
                    
                    resistTypes.forEach(resistType => {
                        const resistData = individualResistScores[resistType];
                        if (resistData) {
                            totalRawValue += resistData.value;
                            // Weight per resist is total weight / num_resists
                            const effectiveWeight = resistWeightPerResist * resistData.weight;  // weight is always 1.0
                            const resistPoints = resistData.score * effectiveWeight;
                            totalAdvancedPoints += resistPoints;
                            totalResistScore += resistData.score * effectiveWeight;
                            totalResistWeight += effectiveWeight;
                            // Display the per-resist weight (total weight / num_resists)
                            const resistPctOfTotal = (resistPoints / totalPoints * 100).toFixed(1);
                            html += `<tr><td style="padding-left: 20px;">${resistType}</td><td>${resistData.value}</td><td>${formatScore(resistData.score)}</td><td>${resistWeightPerResist.toFixed(2)}</td><td>${resistPoints.toFixed(2)}</td><td>${resistPctOfTotal}%</td></tr>`;
                        }
                    });
                    
                    // Calculate average resist score percentage
                    const avgResistPct = totalResistWeight > 0 ? (totalResistScore / totalResistWeight) : (scores.resists_pct || 0);
                    
                    const resistsTotalPctOfTotal = (totalAdvancedPoints / totalPoints * 100).toFixed(1);
                    html += `<tr><td><strong>Total</strong></td><td><strong>${totalRawValue.toLocaleString()}</strong></td><td><strong>${formatScore(avgResistPct)}</strong></td><td><strong>${rawResistWeight.toFixed(2)}</strong></td><td><strong>${totalAdvancedPoints.toFixed(2)}</strong></td><td><strong>${resistsTotalPctOfTotal}%</strong></td></tr>`;
                    totalStatPoints += totalAdvancedPoints;
                } else {
                    // Use simple total resists
                    const resistsPct = (scores.resists_pct !== undefined && scores.resists_pct !== null && typeof scores.resists_pct === 'number') ? scores.resists_pct : 0;
                    const resistsPoints = resistsPct * normalizedResistWeight;  // Use normalized weight for calculation
                    totalStatPoints += resistsPoints;
                    const resistsPctOfTotal = (resistsPoints / totalPoints * 100).toFixed(1);
                    html += `<tr><td>Resists</td><td>${resistsValue.toLocaleString()}</td><td>${formatScore(resistsPct)}</td><td>${rawResistWeight.toFixed(2)}</td><td>${resistsPoints.toFixed(2)}</td><td>${resistsPctOfTotal}%</td></tr>`;
                }
            }
            
            const displayStatTotal = useComputedPoints ? char.stat_points : totalStatPoints;
            const statTotalPctOfTotal = (displayStatTotal / totalPoints * 100).toFixed(1);
            html += `<tr style="border-top: 2px solid #333; font-weight: bold;"><td><strong>Stat Total</strong></td><td colspan="3"></td><td><strong>${displayStatTotal.toFixed(2)}</strong></td><td><strong>${statTotalPctOfTotal}%</strong></td></tr>`;
            html += `</tbody></table>`;
            
            // Focus Scores
            const focusScores = scores.focus_scores || {};
            const focusDetails = scores.focus_details || {};
            const charFocii = char.focii || {};
            const charDamageFocii = char.damage_focii || {};
            const charManaEffCats = char.mana_efficiency_cats || {};
            const charSpellHasteCats = char.spell_haste_cats || {};
            const charDurationCats = char.duration_cats || {};
            
            if (Object.keys(focusScores).length > 0) {
                html += `<h3>Focus Scores</h3>`;
                html += `<table><thead><tr><th>Focus</th><th>Raw Value</th><th>Score %</th><th>Weight</th><th>Points</th><th>% of total</th></tr></thead><tbody>`;
                
                // For Warriors/Pal/SK, calculate focus weight as 2.4x HP weight (after normalization)
                // For other classes, use the focus weights from config
                let totalFocusWeight = 0;
                const charClass = char.class || '';
                if (charClass === 'Warrior' || charClass === 'Paladin' || charClass === 'Shadow Knight') {
                    // Calculate normalized weights first
                    // Sum all stat weights
                    let totalStatWeight = 0;
                    // ATK and Haste are now in focus weights, not stat weights
            const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
                    statKeys.forEach(key => {
                        totalStatWeight += classWeightConfig[key] || 0;
                    });
                    
                    // Calculate total focus weight (2.4x HP weight before normalization)
                    const rawHpWeight = classWeightConfig.hp_pct || 0;
                    const rawFocusWeight = rawHpWeight * 2.4;
                    
                    // Total weight before normalization = stat weights + focus weights
                    const totalRawWeight = totalStatWeight + rawFocusWeight;
                    
                    // Normalized focus weight = (raw focus weight / total raw weight)
                    if (totalRawWeight > 0) {
                        totalFocusWeight = rawFocusWeight / totalRawWeight;
                    }
                } else {
                    // Sum all focus weights (these are already normalized in the JSON)
                    for (const [cat, weight] of Object.entries(focusWeights)) {
                        if (typeof weight === 'object') {
                            totalFocusWeight += Object.values(weight).reduce((a, b) => a + b, 0);
                        } else {
                            totalFocusWeight += weight;
                        }
                    }
                }
                
                // Helper function to get raw value for a focus category
                function getRawFocusValue(focusCat) {
                    if (focusCat === 'Spell Damage') {
                        // Get the best damage type value
                        const damageTypes = Object.keys(charDamageFocii);
                        if (damageTypes.length > 0) {
                            const bestType = damageTypes.reduce((a, b) => charDamageFocii[a] > charDamageFocii[b] ? a : b);
                            return charDamageFocii[bestType] || 0;
                        }
                        return 0;
                    } else if (focusCat === 'Spell Mana Efficiency') {
                        // Get the best mana efficiency category
                        const cats = Object.keys(charManaEffCats);
                        if (cats.length > 0) {
                            const bestCat = cats.reduce((a, b) => charManaEffCats[a] > charManaEffCats[b] ? a : b);
                            return charManaEffCats[bestCat] || 0;
                        }
                        return 0;
                    } else if (focusCat === 'Beneficial Spell Haste' || focusCat === 'Detrimental Spell Haste') {
                        const hasteCat = focusCat === 'Beneficial Spell Haste' ? 'Bene' : 'Det';
                        return charSpellHasteCats[hasteCat] || 0;
                    } else if (focusCat === 'Buff Spell Duration' || focusCat === 'Beneficial Spell Duration') {
                        // All Spell Duration counts for Buff at its %; use max(Bene, All)
                        return Math.max(charDurationCats['Bene'] || 0, charDurationCats['All'] || 0);
                    } else if (focusCat === 'Detrimental Spell Duration') {
                        // All Spell Duration counts for Det at its %; use max(Det, All)
                        return Math.max(charDurationCats['Det'] || 0, charDurationCats['All'] || 0);
                    } else if (focusCat === 'All Spell Duration') {
                        return charDurationCats['All'] || 0;
                    } else if (focusCat === 'Haste') {
                        // Haste is binary, show the item haste value
                        const hasteValue = char.stats?.haste || 0;
                        return hasteValue >= 30 ? 30 : hasteValue;
                    } else if (focusCat === "Time's Antithesis" || focusCat === 'Serpent of Vindication') {
                        // Binary item focus: 100 if has item, 0 otherwise
                        return (focusScores[focusCat] === 100) ? 100 : 0;
                    } else {
                        // For other focuses, get from charFocii
                        return charFocii[focusCat] || 0;
                    }
                }
                
                const bardInstrumentCats = ['Brass', 'Percussion', 'Singing', 'Strings', 'Wind'];
                const focusTableRows = [];
                for (const [focusCat, score] of Object.entries(focusScores)) {
                    // Skip composite Spell Haste when we show Beneficial/Detrimental separately
                    if (focusCat === 'Spell Haste' && (focusScores['Beneficial Spell Haste'] !== undefined || focusScores['Detrimental Spell Haste'] !== undefined)) {
                        continue;
                    }
                    // When focus_details exists for this category (e.g. Spell Mana Efficiency), show one row per subcategory
                    if (focusDetails[focusCat] && Array.isArray(focusDetails[focusCat])) {
                        const rows = focusDetails[focusCat];
                        const parentWeight = (typeof focusWeights[focusCat] === 'number') ? focusWeights[focusCat] : 0;
                        const sumWeightShare = rows.reduce((s, r) => s + (r.weight_share || 0), 0);
                        rows.forEach(row => {
                            const rowWeight = sumWeightShare > 0 && parentWeight > 0
                                ? (row.weight_share / sumWeightShare) * parentWeight : 0;
                            const focusPoints = (row.score_pct || 0) * rowWeight;
                            totalFocusPoints += focusPoints;
                            const focusPctOfTotal = (focusPoints / totalPoints * 100).toFixed(1);
                            const displayName = focusCat + ' (' + (row.label || row.cat) + ')';
                            focusTableRows.push({ focusPoints, html: `<tr><td>${escapeHtml(displayName)}</td><td>${(row.raw != null ? row.raw + '%' : 'N/A')}</td><td>${formatScore(row.score_pct)}</td><td>${rowWeight.toFixed(2)}</td><td>${focusPoints.toFixed(2)}</td><td>${focusPctOfTotal}%</td></tr>` });
                        });
                        continue;
                    }
                    let weight = 0;
                    let rawValue = bardInstrumentCats.includes(focusCat) && (scores.focus_items || {})[focusCat] != null
                        ? scores.focus_items[focusCat]
                        : getRawFocusValue(focusCat);
                    
                    if (focusCat === 'Spell Damage') {
                        // Spell Damage has nested weights
                        const damageWeights = focusWeights['Spell Damage'] || {};
                        weight = Object.values(damageWeights).reduce((a, b) => a + b, 0);
                    } else if (focusCat === 'Haste') {
                        // Use normalized weight from focusWeights (which is already normalized)
                        weight = focusWeights[focusCat] || 0;
                    } else if (focusCat === 'Darkblade' || focusCat === 'Raex Chest') {
                        // Warrior focus items - use normalized weight from focusWeights
                        weight = focusWeights[focusCat];
                        if (weight === undefined || weight === null) {
                            // Debug: log what's in focusWeights and raw focus dict
                            const rawWeights = originalClassWeights[charClass] || classWeights[charClass] || {};
                            const rawFocus = rawWeights.focus || {};
                            console.warn(`Weight missing for ${focusCat}. Available normalized focus weights:`, Object.keys(focusWeights));
                            console.warn(`Raw focus dict for ${charClass}:`, rawFocus);
                            console.warn(`Raw weights for ${charClass}:`, rawWeights);
                            weight = 0;
                        }
                        // These are binary (100 or 0), so raw value is the score
                        rawValue = score === 100 ? 100 : 0;
                    } else if (focusCat === 'Shield of Strife' || focusCat === 'Serpent of Vindication' || 
                               focusCat === 'Healing Enhancement' || focusCat === 'Beneficial Spell Haste' || 
                               focusCat === 'Detrimental Spell Haste' || focusCat === 'ATK') {
                        // For specific focus items, use normalized weight from focusWeights
                        weight = focusWeights[focusCat] || 0;
                        
                        if (focusCat === 'Shield of Strife' || focusCat === 'Serpent of Vindication') {
                            // These are binary (100 or 0), so raw value is the score
                            rawValue = score === 100 ? 100 : 0;
                        } else if (focusCat === 'Haste') {
                            // Haste is binary, show the item haste value
                            const hasteValue = char.stats?.haste || 0;
                            rawValue = hasteValue >= 30 ? 30 : hasteValue;
                        }
                    } else if (focusCat === 'FT') {
                        weight = focusWeights['FT'] || 0;
                        if (weight > 0 && (scores.ft_capped !== undefined || scores.ft_current !== undefined)) {
                            rawValue = scores.ft_capped ? 100 : (scores.ft_pct != null ? scores.ft_pct : 0);
                        }
                    } else {
                        weight = focusWeights[focusCat] || 0;
                    }
                    
                    // Format raw value
                    let rawDisplay = 'N/A';
                    if (rawValue > 0 || (bardInstrumentCats.includes(focusCat) && rawValue === 0)) {
                        if (focusCat === 'Haste') {
                            rawDisplay = `${rawValue}% (${rawValue >= 30 ? 'Capped' : 'Not Capped'})`;
                        } else if (focusCat === 'FT') {
                            const ftCurrent = scores.ft_current != null ? scores.ft_current : 0;
                            const ftCap = scores.ft_cap != null ? scores.ft_cap : 15;
                            rawDisplay = `${ftCurrent}/${ftCap}`;
                        } else if (bardInstrumentCats.includes(focusCat)) {
                            rawDisplay = `${Number(rawValue).toFixed(0)}%`;
                        } else {
                            rawDisplay = `${rawValue.toFixed(1)}%`;
                        }
                    }
                    
                    const focusPoints = score * weight;
                    totalFocusPoints += focusPoints;
                    const focusPctOfTotal = (focusPoints / totalPoints * 100).toFixed(1);
                    let rowHtml = `<tr><td>${escapeHtml(focusCat === 'FT' ? 'FT (Flowing Thought)' : focusCat)}</td><td>${rawDisplay}</td><td>${formatScore(score)}</td><td>${weight.toFixed(2)}</td><td>${focusPoints.toFixed(2)}</td><td>${focusPctOfTotal}%</td></tr>`;
                    // When not at max for this focus, show upgrade options (items that could give it, with %) – upgrades only, and usable by class
                    const focusSources = scores.focus_sources || {};
                    const currentRaw = (focusSources[focusCat] && focusSources[focusCat].length) ? Math.max(0, ...focusSources[focusCat].map(s => (s.value != null ? Number(s.value) : 0))) : 0;
                    const filteredCandidates = filterFocusCandidates(focusCandidates[focusCat], currentRaw, char.class);
                    if (score < 100 && weight > 0 && filteredCandidates.length > 0) {
                        const maxShow = 50;
                        const candidateLinks = filteredCandidates.slice(0, maxShow).map(s => {
                            const id = (s.item_id != null && s.item_id !== '') ? s.item_id : '';
                            const valStr = (s.value !== undefined && s.value !== null) ? ` ${s.value}%` : '';
                            return `<a class="item-link" href="https://www.takproject.net/allaclone/item.php?id=${id}" target="_blank" data-item-id="${id}" data-item-name="${escapeHtml(s.item_name || '')}">${escapeHtml(s.item_name || '')}</a>${valStr}`;
                        }).join(', ');
                        const more = filteredCandidates.length > maxShow ? ` (+${filteredCandidates.length - maxShow} more)` : '';
                        const label = score === 0 ? 'Items that could give this focus (with %):' : 'Upgrades (with %):';
                        rowHtml += `<tr><td colspan="6" class="focus-candidates-row">${label} ${candidateLinks}${more}</td></tr>`;
                    }
                    focusTableRows.push({ focusPoints, html: rowHtml });
                }
                
                // ATK - part of focus weight (only show if not already in focus_scores)
                if (scores.atk_pct !== undefined && scores.atk_pct !== null && !focusScores['ATK']) {
                    const atkWeight = focusWeights['ATK'] || 0;
                    if (atkWeight > 0) {
                        const atkPoints = scores.atk_pct * atkWeight;
                        totalFocusPoints += atkPoints;
                        const atkPctOfTotal = (atkPoints / totalPoints * 100).toFixed(1);
                        focusTableRows.push({ focusPoints: atkPoints, html: `<tr><td>ATK</td><td>${char.stats.atk_item || 'N/A'}</td><td>${formatScore(scores.atk_pct)}</td><td>${atkWeight.toFixed(2)}</td><td>${atkPoints.toFixed(2)}</td><td>${atkPctOfTotal}%</td></tr>` });
                    }
                }
                
                if (scores.haste_pct !== undefined && scores.haste_pct !== null && !focusScores['Haste']) {
                    const hasteWeight = focusWeights['Haste'] || 0;
                    if (hasteWeight > 0) {
                        const hastePoints = scores.haste_pct * hasteWeight;
                        totalFocusPoints += hastePoints;
                        const hastePctOfTotal = (hastePoints / totalPoints * 100).toFixed(1);
                        focusTableRows.push({ focusPoints: hastePoints, html: `<tr><td>Haste</td><td>${scores.haste_value || 'N/A'}%</td><td>${formatScore(scores.haste_pct)}</td><td>${hasteWeight.toFixed(2)}</td><td>${hastePoints.toFixed(2)}</td><td>${hastePctOfTotal}%</td></tr>` });
                    }
                }
                
                // Order focus rows by overall score (points) descending
                focusTableRows.sort((a, b) => b.focusPoints - a.focusPoints);
                focusTableRows.forEach(r => { html += r.html; });
                
                const displayFocusTotal = useComputedPoints ? char.focus_points : totalFocusPoints;
                const focusTotalPctOfTotal = (displayFocusTotal / totalPoints * 100).toFixed(1);
                html += `<tr style="border-top: 2px solid #333; font-weight: bold;"><td><strong>Focus Total</strong></td><td colspan="3"></td><td><strong>${displayFocusTotal.toFixed(2)}</strong></td><td><strong>${focusTotalPctOfTotal}%</strong></td></tr>`;
                html += `</tbody></table>`;
                
                // Focus breakdown: all focuses we're scored on, with bar and sources (uses same focusWeights as sliders, so updates when sliders change)
                const focusSources = scores.focus_sources || {};
                const slotNames = { 0: 'Charm', 1: 'Ear', 2: 'Head', 3: 'Face', 4: 'Ear', 5: 'Neck', 6: 'Shoulder', 7: 'Arms', 8: 'Back', 9: 'Wrist', 10: 'Wrist', 11: 'Range', 12: 'Hands', 13: 'Main Hand', 14: 'Off Hand', 15: 'Primary', 16: 'Secondary', 17: 'Chest', 18: 'Legs', 19: 'Feet', 20: 'Waist', 21: 'Power Source', 22: 'Ammo' };
                function getScoredFocusKeys(fw) {
                    const keys = [];
                    if (!fw) return keys;
                    for (const [k, v] of Object.entries(fw)) {
                        if (typeof v === 'object' && v !== null) {
                            for (const sub of Object.keys(v)) {
                                const w = (v[sub] != null && typeof v[sub] === 'number') ? v[sub] : 0;
                                if (w > 0) keys.push(k === 'Spell Damage' ? `Spell Damage (${sub})` : `${k} (${sub})`);
                            }
                        } else if (typeof v === 'number' && v > 0) {
                            keys.push(k);
                        }
                    }
                    return keys;
                }
                const scoredFocusKeys = getScoredFocusKeys(focusWeights);
                if (scoredFocusKeys.length > 0) {
                    scoredFocusKeys.sort((a, b) => getWeightForFocusKey(b, focusWeights) - getWeightForFocusKey(a, focusWeights));
                    html += `<div class="focus-breakdown-section"><h3>Focus breakdown (what you're scored on)</h3>`;
                    const focusDetails = scores.focus_details || {};
                    scoredFocusKeys.forEach(focusKey => {
                        let scorePct = focusScores[focusKey];
                        if (scorePct === undefined && focusKey === 'Spell Damage') scorePct = focusScores['Spell Damage'];
                        // Resolve score for composite keys (e.g. "Spell Mana Efficiency (Bene)") from focus_details
                        if (scorePct === undefined) {
                            const match = focusKey.match(/^(.+)\s+\(([^)]+)\)$/);
                            if (match) {
                                const [, parent, sub] = match;
                                const rows = focusDetails[parent];
                                if (Array.isArray(rows)) {
                                    const row = rows.find(r => (r.cat || r.label) === sub || (r.label && r.label.toLowerCase().startsWith(sub.toLowerCase())));
                                    if (row != null && row.score_pct != null) scorePct = row.score_pct;
                                }
                            }
                        }
                        if (scorePct === undefined) scorePct = 0;
                        const barClass = scorePct >= 80 ? 'high' : scorePct >= 40 ? 'mid' : scorePct > 0 ? 'low' : 'none';
                        let sources = focusSources[focusKey];
                        if (!sources && focusKey === 'Spell Mana Efficiency') {
                            sources = [];
                            ['Det', 'Bene', 'Nuke', 'Sanguine'].forEach(sub => {
                                const s = focusSources['Spell Mana Efficiency (' + sub + ')'];
                                if (s) sources = sources.concat(s);
                            });
                        }
                        let sourceHtml = '';
                        if (sources && sources.length > 0) {
                            sourceHtml = sources.map(s => {
                                const slotName = slotNames[s.slot_id] || `Slot ${s.slot_id}`;
                                const valStr = (s.value !== undefined && s.value !== null) ? ` ${s.value}%` : '';
                                const id = (s.item_id != null && s.item_id !== '') ? s.item_id : (char.inventory?.find(i => i.slot_id === s.slot_id)?.item_id || '');
                                return `<a class="item-link" href="https://www.takproject.net/allaclone/item.php?id=${id}" target="_blank" data-item-id="${id}" data-item-name="${escapeHtml(s.item_name || '')}">${escapeHtml(s.item_name || '')}</a> (${slotName})${valStr}`;
                            }).join(', ');
                            sourceHtml = `<span class="focus-breakdown-sources">From: ${sourceHtml}</span>`;
                        }
                        const weightForFocus = (() => {
                            const fw = focusWeights[focusKey] ?? (focusKey.startsWith('Spell Damage (') ? (focusWeights['Spell Damage'] && Object.values(focusWeights['Spell Damage']).reduce((a, b) => a + b, 0)) : 0);
                            return typeof fw === 'number' ? fw : 0;
                        })();
                        // When not at max for this category, show upgrade options (upgrades only, usable by class)
                        const currentRawBreakdown = (sources && sources.length) ? Math.max(0, ...sources.map(s => (s.value != null ? Number(s.value) : 0))) : 0;
                        const filteredBreakdown = filterFocusCandidates(focusCandidates[focusKey], currentRawBreakdown, char.class);
                        if (scorePct < 100 && weightForFocus > 0 && filteredBreakdown.length > 0) {
                            const maxShow = 50;
                            const candidateLinks = filteredBreakdown.slice(0, maxShow).map(s => {
                                const id = (s.item_id != null && s.item_id !== '') ? s.item_id : '';
                                const valStr = (s.value !== undefined && s.value !== null) ? ` ${s.value}%` : '';
                                return `<a class="item-link" href="https://www.takproject.net/allaclone/item.php?id=${id}" target="_blank" data-item-id="${id}" data-item-name="${escapeHtml(s.item_name || '')}">${escapeHtml(s.item_name || '')}</a>${valStr}`;
                            }).join(', ');
                            const more = filteredBreakdown.length > maxShow ? ` (+${filteredBreakdown.length - maxShow} more)` : '';
                            const label = scorePct === 0 ? 'Items that could give this (with %):' : 'Upgrades (with %):';
                            sourceHtml = (sourceHtml ? sourceHtml + ' ' : '') + `<span class="focus-breakdown-candidates">${label} ${candidateLinks}${more}</span>`;
                        }
                        const displayName = focusKey === 'FT' ? 'FT (Flowing Thought)' : focusKey;
                        html += `<div class="focus-breakdown-item"><div class="focus-breakdown-name">${escapeHtml(displayName)}</div><div class="focus-breakdown-bar-wrap"><div class="focus-breakdown-bar ${barClass}" style="width:${Math.min(100, Math.max(0, scorePct))}%"></div></div><div class="focus-breakdown-value">${formatScore(scorePct)}</div>${sourceHtml}</div>`;
                    });
                    html += `</div>`;
                }
                
                // Overall total = Stat Total + Focus Total (from recalculateScores; works with dynamic reweighting)
                // This ensures consistency with the ranking calculation
                const overallTotal = char.total_points !== undefined ? char.total_points : (totalStatPoints + totalFocusPoints);
                html += `<h3 style="margin-top: 20px;">Overall Total: ${overallTotal.toFixed(2)} points</h3>`;
                html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Total = Stat Total + Focus Total (sum of all row Points above).</p>`;
                // Calculate class maximum safely
                let classMaxDisplay = 'N/A';
                if (char.overall_score > 0 && char.total_points !== undefined) {
                    const classMax = char.total_points / (char.overall_score / 100.0);
                    if (!isNaN(classMax) && isFinite(classMax)) {
                        classMaxDisplay = classMax.toFixed(2);
                    }
                }
                html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum of ${classMaxDisplay} points)</p>`;
            } else {
                // No focus scores, just show stat total
                const overallTotal = char.total_points !== undefined ? char.total_points : totalStatPoints;
                html += `<h3 style="margin-top: 20px;">Overall Total: ${overallTotal.toFixed(2)} points</h3>`;
                if (char.overall_score > 0 && char.total_points !== undefined) {
                    const maxForClass = char.total_points / (char.overall_score / 100.0);
                    if (!isNaN(maxForClass) && isFinite(maxForClass)) {
                        html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum of ${maxForClass.toFixed(2)} points)</p>`;
                    } else {
                        html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum)</p>`;
                    }
                } else {
                    html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum)</p>`;
                }
            }
            
            // Gear display with item links (worn slots 1-22 only)
            const equippedOnly = (char.inventory || []).filter(item => item.slot_id >= 1 && item.slot_id <= 22);
            if (equippedOnly.length > 0) {
                html += `<h3>Equipped Gear</h3>`;
                html += `<div style="display: flex; flex-wrap: wrap; gap: 10px;">`;
                const slotNames = {
                    0: 'Charm', 1: 'Ear', 2: 'Head', 3: 'Face', 4: 'Ear', 5: 'Neck',
                    6: 'Shoulder', 7: 'Arms', 8: 'Back', 9: 'Wrist', 10: 'Wrist',
                    11: 'Range', 12: 'Hands', 13: 'Main Hand', 14: 'Off Hand',
                    15: 'Primary', 16: 'Secondary', 17: 'Chest', 18: 'Legs',
                    19: 'Feet', 20: 'Waist', 21: 'Power Source', 22: 'Ammo'
                };
                equippedOnly.forEach(item => {
                    const slotName = slotNames[item.slot_id] || `Slot ${item.slot_id}`;
                    const itemLink = `<a class="item-link" href="https://www.takproject.net/allaclone/item.php?id=${item.item_id}" target="_blank" data-item-id="${item.item_id}" data-item-name="${escapeHtml(item.item_name || '')}">${escapeHtml(item.item_name || `Item ${item.item_id}`)}</a>`;
                    html += `<div style="padding: 5px; background: #f0f0f0; border-radius: 3px;"><strong>${slotName}:</strong> ${itemLink}</div>`;
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            modalContent.innerHTML = html;
            modal.style.display = 'block';
        }

        // --- Item cards (hover popover), using DKP-style logic + local purple theme ---
        const TAKP_ITEM_BASE = 'https://www.takproject.net/allaclone/item.php?id=';
        const TAKP_SPELL_BASE = 'https://www.takproject.net/allaclone/spell.php?id=';
        const HOVER_DELAY_MS = 400;
        const POPOVER_OFFSET = 8;
        let itemStatsCache = {};
        let itemNameToId = {};  // normalized name -> item id (for links that have name but no id)
        let itemStatsLoadPromise = null;

        /** Normalize item name for lookup: lowercase, collapse spaces, remove apostrophe/backtick (match Python normalize_item_name). */
        function normalizeItemNameForLookup(name) {
            if (name == null || typeof name !== 'string') return '';
            return name.toLowerCase().replace(/['`\u2019]/g, '').replace(/\s+/g, ' ').trim();
        }

        /** Resolve item name to id from itemNameToId (exact + variants so more cards work despite name spelling differences). */
        function resolveItemIdByName(itemName) {
            if (!itemName || typeof itemName !== 'string') return null;
            const norm = normalizeItemNameForLookup(itemName);
            if (!norm) return null;
            let id = itemNameToId[norm];
            if (id != null) return id;
            const withoutThe = norm.replace(/\s+the\s+/g, ' ').trim();
            if (withoutThe !== norm) { id = itemNameToId[withoutThe]; if (id != null) return id; }
            const withThe = norm.replace(/\s+of\s+/, ' of the ');
            if (withThe !== norm) { id = itemNameToId[withThe]; if (id != null) return id; }
            const noLeadingThe = norm.replace(/^the\s+/, '').trim();
            if (noLeadingThe !== norm) { id = itemNameToId[noLeadingThe]; if (id != null) return id; }
            return null;
        }

        /** Normalize magelo item_stats format (string flags/mods/resists) to DKP-style (arrays) for the card renderer. */
        function normalizeItemStats(raw) {
            if (!raw || typeof raw !== 'object') return raw;
            const out = { ...raw };
            if (typeof raw.flags === 'string' && raw.flags.trim()) {
                out.flags = raw.flags.split(/\s*\|\s*/).map(s => s.trim()).filter(Boolean);
            } else if (!Array.isArray(out.flags)) out.flags = [];
            if (typeof raw.mods === 'string' && raw.mods.trim()) {
                out.mods = raw.mods.split(',').map(s => s.trim()).filter(Boolean).map(part => {
                    const m = part.match(/^([A-Za-z]+):\s*(-?\d+)$/);
                    if (m) return { label: m[1], value: parseInt(m[2], 10) };
                    return { label: part.replace(/:.*$/, '').trim(), value: part.replace(/^[^:]+:\s*/, '').trim() };
                });
            } else if (!Array.isArray(out.mods)) out.mods = [];
            if (typeof raw.resists === 'string' && raw.resists.trim()) {
                out.resists = raw.resists.split(',').map(s => s.trim()).filter(Boolean).map(part => {
                    const m = part.match(/^([A-Za-z]+):\s*(-?\d+)$/);
                    if (m) return { label: m[1], value: parseInt(m[2], 10) };
                    return { label: part.replace(/:.*$/, '').trim(), value: part.replace(/^[^:]+:\s*/, '').trim() };
                });
            } else if (!Array.isArray(out.resists)) out.resists = [];
            if (raw.effect != null && raw.effect !== '') { out.effectSpellName = raw.effect; }
            if (raw.focus != null && raw.focus !== '') { out.focusSpellName = raw.focus; }
            if (raw.required_level != null && raw.required_level !== '') {
                const rl = parseInt(raw.required_level, 10);
                out.requiredLevel = isNaN(rl) ? raw.required_level : rl;
            }
            if (out.ac === '') out.ac = null;
            if (out.weight === '') out.weight = null;
            return out;
        }

        /** Load item_name_to_id.json (normalized name -> id) first so name resolution works for all raid/DKP items. */
        function loadItemNameToId() {
            const baseDir = window.location.pathname.replace(/\/[^/]*$/, '/');
            const paths = [
                new URL('data/item_name_to_id.json', document.baseURI).href,
                'data/item_name_to_id.json',
                './data/item_name_to_id.json',
                baseDir + 'data/item_name_to_id.json'
            ];
            return (async () => {
                for (const path of paths) {
                    try {
                        const r = await fetch(path);
                        if (!r.ok) continue;
                        const obj = await r.json();
                        if (obj && typeof obj === 'object') {
                            for (const [norm, id] of Object.entries(obj)) {
                                if (norm && (itemNameToId[norm] === undefined || itemNameToId[norm] === null))
                                    itemNameToId[norm] = Number(id);
                            }
                            return;
                        }
                    } catch (e) { /* try next */ }
                }
            })();
        }

        function loadItemStats() {
            if (itemStatsLoadPromise == null) {
                const baseDir = window.location.pathname.replace(/\/[^/]*$/, '/');
                // Prefer path relative to page (GitHub Pages: /repo/class_rankings.html -> /repo/data/item_stats.json)
                const possiblePaths = [
                    baseDir + 'data/item_stats.json',
                    new URL('data/item_stats.json', document.baseURI).href,
                    'data/item_stats.json',
                    './data/item_stats.json',
                ];

                itemStatsLoadPromise = (async () => {
                    await loadItemNameToId();
                    for (const path of possiblePaths) {
                        try {
                            const r = await fetch(path);
                            if (!r.ok) continue;
                            const obj = await r.json();
                            if (obj && typeof obj === 'object') {
                                for (const [k, v] of Object.entries(obj)) {
                                    if (v != null && typeof v === 'object' && Object.keys(v).length > 0) {
                                        const id = Number(k);
                                        itemStatsCache[id] = normalizeItemStats(v);
                                        const name = (v.name || '').toString().trim();
                                        if (name) {
                                            const norm = normalizeItemNameForLookup(name);
                                            if (norm && itemNameToId[norm] === undefined) itemNameToId[norm] = id;
                                        }
                                    }
                                }
                                return obj;
                            }
                        } catch (e) { /* try next path */ }
                    }
                    console.warn('Item stats: could not load data/item_stats.json from any path. Check Network tab for 404.');
                    return {};
                })();
            }
            return itemStatsLoadPromise;
        }

        function getItemStats(itemId) {
            if (itemId == null || itemId === '') return Promise.resolve(null);
            const id = Number(itemId);
            if (itemStatsCache[id]) return Promise.resolve(itemStatsCache[id]);
            return loadItemStats().then(() => itemStatsCache[id] || null);
        }

        function spellLinkHtml(spellId, name) {
            if (spellId == null || !name) return escapeHtml(name || '');
            return `<a class="item-card__spell-link" href="${TAKP_SPELL_BASE}${spellId}" target="_blank" rel="noopener noreferrer">${escapeHtml(name)}</a>`;
        }

        function renderItemCardHtml(name, itemId, stats, compact) {
            const href = itemId != null && itemId !== '' ? TAKP_ITEM_BASE + itemId : '#';
            const displayName = name || 'Unknown item';
            const titleLink = href !== '#' ? `<a href="${href}" target="_blank" rel="noopener noreferrer">${escapeHtml(displayName)}</a>` : `<span>${escapeHtml(displayName)}</span>`;
            if (compact || !stats) {
                return `<div class="item-card item-card--compact ItemOuter"><div class="ItemTitle"><div class="ItemTitleLeft"></div><div class="ItemTitleMid">${titleLink}</div><div class="ItemTitleRight"></div></div></div>`;
            }
            const flags = stats.flags || [];
            const slot = stats.slot;
            const skill = stats.skill;
            const ac = stats.ac;
            const atkDelay = stats.atkDelay;
            const dmg = stats.dmg;
            const dmgBonus = stats.dmgBonus;
            const dmgBonusNote = stats.dmgBonusNote;
            const mods = stats.mods || [];
            const resists = stats.resists || [];
            const instrumentMods = stats.instrumentMods || [];
            const levelType = stats.levelType || 'required';
            const requiredLevel = stats.requiredLevel;
            const effectSpellId = stats.effectSpellId;
            const effectSpellName = stats.effectSpellName;
            const effectNote = stats.effectNote;
            const focusSpellId = stats.focusSpellId;
            const focusSpellName = stats.focusSpellName;
            const weight = stats.weight;
            const size = stats.size;
            const classes = stats.classes;
            const races = stats.races;
            const skillMod = stats.skillMod;
            const light = stats.light;
            const tint = stats.tint;
            const levelStr = requiredLevel != null ? (levelType === 'recommended' ? `Recommended level of ${requiredLevel}.` : `Required level of ${requiredLevel}.`) : null;
            const statsLine = mods.length > 0 ? mods.map(m => {
                const v = m.value;
                const plus = (typeof v === 'number' && (m.label === 'HP' || m.label === 'MANA')) ? (v >= 0 ? '+' : '') + v : v;
                return `${m.label}: ${plus}`;
            }).join(' ') : null;
            const resistsLine = resists.length > 0 ? resists.map(r => `${r.label}: ${r.value}`).join(' ') : null;
            let inner = '';
            if (flags.length > 0) inner += flags.join('  ') + '<br>';
            if (slot) inner += 'Slot: ' + slot + '<br>';
            if (skill && atkDelay != null && dmg != null) inner += 'Skill: ' + skill + ' Atk Delay: ' + atkDelay + '<br>';
            if (skill && dmg != null) {
                inner += 'DMG: ' + dmg + (dmgBonus != null ? ' Dmg bonus:' + dmgBonus + (dmgBonusNote ? ' <i>' + escapeHtml(dmgBonusNote) + '</i> ' : '') : '') + (ac != null ? ' AC: ' + ac : '') + '<br>';
            }
            if (!skill && ac != null) inner += ' AC: ' + ac + '<br>';
            if (effectSpellId != null || effectSpellName) inner += 'Effect: ' + spellLinkHtml(effectSpellId, effectSpellName) + (effectNote ? ' ' + escapeHtml(effectNote) : '') + '<br>';
            if (skillMod) inner += 'Skill Mod: ' + skillMod + '<br>';
            if (statsLine) inner += statsLine + '<br>';
            if (resistsLine) inner += resistsLine + '<br>';
            instrumentMods.forEach(inst => {
                inner += (inst.label != null && inst.label !== '' ? inst.label + ': ' : '') + inst.value + (inst.pct != null ? ' <i>(' + inst.pct + ')</i>' : '') + '<br>';
            });
            if (levelStr) inner += levelStr + '<br>';
            if (focusSpellId != null || focusSpellName) inner += 'Focus: ' + spellLinkHtml(focusSpellId, focusSpellName) + '<br>';
            if (weight != null || size) inner += 'WT: ' + (weight != null ? weight : '?') + ' Size: ' + (size || '?') + '<br>';
            if (classes) inner += 'Class: ' + classes + '<br>';
            if (races) inner += 'Race: ' + races + '<br>';
            if (light != null) inner += 'Light: ' + light + '<br>';
            if (tint) inner += 'Tint: ' + escapeHtml(tint) + '<br>';
            return `<div class="item-card ItemOuter"><div class="ItemTitle"><div class="ItemTitleLeft"></div><div class="ItemTitleMid">${titleLink}</div><div class="ItemTitleRight"></div></div><div class="ItemInner">${inner || ''}</div></div>`;
        }

        let itemCardTimer = null;
        let itemCardHideTimer = null;
        let itemCardPopover = null;

        function showItemCard(anchor, itemId, itemName) {
            if (itemCardHideTimer) { clearTimeout(itemCardHideTimer); itemCardHideTimer = null; }
            if (itemCardPopover) {
                itemCardPopover.remove();
                itemCardPopover = null;
            }
            const id = itemId != null && itemId !== '' ? String(itemId).trim() : null;
            function showCard(useId, stats) {
                const compact = !stats;
                const cardHtml = renderItemCardHtml(itemName || 'Item', useId, stats, compact);
                const pop = document.createElement('div');
                pop.className = 'item-card-popover';
                pop.innerHTML = cardHtml;
                pop.setAttribute('role', 'tooltip');
                document.body.appendChild(pop);
                itemCardPopover = pop;
                const cardWidth = 320;
                const cardHeight = 400;
                const rect = anchor.getBoundingClientRect();
                let left = rect.left + rect.width + POPOVER_OFFSET;
                let top = rect.top;
                if (left + cardWidth > window.innerWidth - 12) left = rect.left - cardWidth - POPOVER_OFFSET;
                if (left < 12) left = 12;
                if (top + cardHeight > window.innerHeight - 12) top = window.innerHeight - cardHeight - 12;
                if (top < 12) top = 12;
                pop.style.left = left + 'px';
                pop.style.top = top + 'px';
                pop.addEventListener('mouseenter', () => {
                    if (itemCardHideTimer) { clearTimeout(itemCardHideTimer); itemCardHideTimer = null; }
                });
                pop.addEventListener('mouseleave', hideItemCard);
            }
            getItemStats(id).then(stats => {
                if (!stats && itemName) {
                    const resolvedId = resolveItemIdByName(itemName);
                    if (resolvedId != null) {
                        return getItemStats(resolvedId).then(s => showCard(String(resolvedId), s));
                    }
                }
                showCard(id, stats);
            });
        }

        function hideItemCard() {
            if (itemCardTimer) {
                clearTimeout(itemCardTimer);
                itemCardTimer = null;
            }
            if (itemCardHideTimer) {
                clearTimeout(itemCardHideTimer);
                itemCardHideTimer = null;
            }
            if (itemCardPopover) {
                itemCardPopover.remove();
                itemCardPopover = null;
            }
        }

        document.body.addEventListener('mouseover', function(e) {
            const link = e.target.closest('.item-link');
            if (!link) {
                if (!e.relatedTarget || !e.relatedTarget.closest || !e.relatedTarget.closest('.item-card-popover')) hideItemCard();
                return;
            }
            if (itemCardHideTimer) { clearTimeout(itemCardHideTimer); itemCardHideTimer = null; }
            if (itemCardTimer) clearTimeout(itemCardTimer);
            let itemId = link.getAttribute('data-item-id');
            const itemName = link.getAttribute('data-item-name') || '';
            const needResolveByName = (!itemId || itemId === '') && itemName;
            if (needResolveByName) {
                // itemNameToId is only populated after loadItemStats(); wait for it then resolve and show card
                loadItemStats().then(() => {
                    const resolvedId = resolveItemIdByName(itemName);
                    if (resolvedId != null) itemId = String(resolvedId);
                    itemCardTimer = setTimeout(() => showItemCard(link, itemId, itemName), HOVER_DELAY_MS);
                });
            } else {
                if ((!itemId || itemId === '') && itemName) {
                    const resolvedId = resolveItemIdByName(itemName);
                    if (resolvedId != null) itemId = String(resolvedId);
                }
                itemCardTimer = setTimeout(() => showItemCard(link, itemId, itemName), HOVER_DELAY_MS);
            }
        });
        document.body.addEventListener('mouseout', function(e) {
            if (e.relatedTarget && e.relatedTarget.closest && (e.relatedTarget.closest('.item-link') || e.relatedTarget.closest('.item-card-popover'))) return;
            if (itemCardTimer) { clearTimeout(itemCardTimer); itemCardTimer = null; }
            itemCardHideTimer = setTimeout(hideItemCard, 150);
        });

        loadData();
        // Preload item_stats so name→id resolution works on first hover (e.g. gear slots that lack item_id in JSON)
        loadItemStats().then(() => {
            const hasNames = Object.keys(itemNameToId).length > 0;
            const hasStats = Object.keys(itemStatsCache).length > 0;
            if (!hasNames && !hasStats) {
                console.warn('Item cards: data/item_name_to_id.json and data/item_stats.json could not be loaded. If you opened this file from disk (file://), serve the folder via a local web server (e.g. npx serve .) for item hover cards to work.');
                const notice = document.createElement('div');
                notice.id = 'item-card-data-notice';
                notice.style.cssText = 'position:fixed;bottom:12px;right:12px;max-width:320px;padding:10px 12px;background:#fff3cd;border:1px solid #ffc107;border-radius:6px;font-size:12px;color:#856404;z-index:9999;box-shadow:0 2px 8px rgba(0,0,0,0.15);';
                notice.textContent = 'Item hover data could not be loaded. If you opened this file from disk, use a local server (e.g. npx serve .) for item cards to work.';
                document.body.appendChild(notice);
                setTimeout(() => { const n = document.getElementById('item-card-data-notice'); if (n) n.remove(); }, 12000);
            }
        }).catch(() => {});
    </script>
</body>
</html>
