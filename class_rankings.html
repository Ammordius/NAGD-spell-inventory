<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAKP Class Rankings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header a {
            color: white;
            text-decoration: underline;
            font-size: 0.9em;
            margin-top: 10px;
            display: inline-block;
        }

        header a:hover {
            color: #f0f0f0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
        }

        .score-breakdown {
            margin-top: 20px;
        }

        .score-breakdown h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .score-breakdown table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .score-breakdown th,
        .score-breakdown td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .score-breakdown th {
            background-color: #667eea;
            color: white;
        }

        .score-breakdown tr:hover {
            background-color: #f5f5f5;
        }

        .clickable-row {
            cursor: pointer;
        }

        .clickable-row:hover {
            background-color: #f0f0f0;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #495057;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }

        .table-container {
            overflow-x: auto;
            max-height: 75vh;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;  /* Allow columns to resize when others are hidden */
        }

        thead {
            position: sticky;
            top: 0;
            background: #667eea;
            color: white;
            z-index: 10;
        }

        th {
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
        }

        tbody tr {
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
        }

        tbody tr:hover {
            background-color: #f8f9fa;
        }

        td {
            padding: 12px 10px;
            font-size: 13px;
        }

        .rank {
            font-weight: 700;
            color: #667eea;
            text-align: center;
        }

        .name {
            font-weight: 600;
        }

        .name a {
            color: #667eea;
            text-decoration: none;
        }

        .name a:hover {
            text-decoration: underline;
        }

        .score {
            text-align: right;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .score.high {
            color: #28a745;
        }

        .score.medium {
            color: #ffc107;
        }

        .score.low {
            color: #dc3545;
        }

        .focus-badge {
            display: inline-block;
            background: #e7f3ff;
            color: #667eea;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            margin: 2px;
        }

        .loading, .error {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-size: 18px;
        }

        .error {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>TAKP Class Rankings</h1>
            <p>Level 65 Character Rankings with Focus Analysis</p>
            <a href="scoring_explanation.html">How are scores calculated?</a>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Filter Class:</label>
                <select id="filterClass">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div class="control-group">
                <label>Sort by:</label>
                <select id="sortBy">
                    <option value="overall">Overall Score</option>
                    <option value="class_rank">Class Rank</option>
                    <option value="hp">HP %</option>
                    <option value="mana">Mana %</option>
                    <option value="ac">AC %</option>
                    <option value="atk">ATK %</option>
                    <option value="focus">Focus Score</option>
                </select>
            </div>
            <div class="control-group">
                <button id="toggleWeights" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Customize Weights
                </button>
            </div>
        </div>

        <div id="weightPanel" style="display: none; background: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 8px; border: 1px solid #dee2e6;">
            <h3 style="margin-top: 0;">Custom Weight Adjustment</h3>
            <p style="color: #6c757d; font-size: 0.9em;">Adjust stat and focus weights to customize rankings. Changes are saved locally and apply to the selected class.</p>
            <div style="margin-bottom: 15px;">
                <label><strong>Class:</strong></label>
                <select id="weightClass" style="margin-left: 10px; padding: 5px;">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div id="weightSliders" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <!-- Sliders will be generated here -->
            </div>
            <div style="margin-top: 20px;">
                <label style="display: flex; align-items: center; margin-bottom: 15px;">
                    <input type="checkbox" id="advancedResists" checked style="margin-right: 8px; width: 18px; height: 18px;">
                    <strong>Advanced Resists</strong>
                    <span style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">
                        (Individual resist scoring: Full weight up to 220, linear decrease to 0.35 at 320, 0.35 from 320-500, 0 above 500)
                    </span>
                </label>
            </div>
            <div style="margin-top: 20px;">
                <button id="resetWeights" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                    Reset to Default
                </button>
                <button id="applyWeights" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Apply Weights
                </button>
            </div>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">Loading rankings data...</div>
            <div id="error" class="error" style="display: none;"></div>
            <table id="rankingsTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Class Rank</th>
                        <th>Name</th>
                        <th>Guild</th>
                        <th>Class</th>
                        <th>Overall</th>
                        <th class="stat-col" data-stat="hp">HP</th>
                        <th class="stat-col" data-stat="mana">Mana</th>
                        <th class="stat-col" data-stat="ac">AC</th>
                        <th class="stat-col" data-stat="atk">ATK</th>
                        <th class="stat-col" data-stat="resists">Resists</th>
                        <th>Focus %</th>
                        <th class="stat-col" data-stat="spelldmg">Spell Dmg %</th>
                        <th>Damage Types</th>
                        <th>Other Focii</th>
                    </tr>
                </thead>
                <tbody id="rankingsBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Score Breakdown Modal -->
    <div id="scoreModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        let characters = [];
        let filteredCharacters = [];
        let filterClass = '';
        let sortBy = 'overall';

        let classWeights = {};
        let customWeights = {}; // User-customized weights
        let originalClassWeights = {}; // Backup of original weights

        // Weight customization functions
        function loadCustomWeights() {
            const saved = localStorage.getItem('customWeights');
            if (saved) {
                try {
                    customWeights = JSON.parse(saved);
                    // Apply custom weights
                    applyCustomWeights();
                } catch (e) {
                    console.error('Error loading custom weights:', e);
                }
            }
        }

        function saveCustomWeights() {
            localStorage.setItem('customWeights', JSON.stringify(customWeights));
        }

        function applyCustomWeights() {
            // Merge custom weights into classWeights
            for (const [className, customWeight] of Object.entries(customWeights)) {
                if (classWeights[className]) {
                    Object.assign(classWeights[className], customWeight);
                }
            }
        }

        function setupWeightControls() {
            // Populate class selector for weights
            const weightClassSelect = document.getElementById('weightClass');
            if (!weightClassSelect) return; // Panel might not exist yet
            
            const classes = new Set(characters.map(c => c.class).filter(c => c));
            [...classes].sort().forEach(cls => {
                const option = document.createElement('option');
                option.value = cls;
                option.textContent = cls;
                weightClassSelect.appendChild(option);
            });

            // Toggle weight panel
            const toggleBtn = document.getElementById('toggleWeights');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    const panel = document.getElementById('weightPanel');
                    if (panel) {
                        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                        if (panel.style.display === 'block') {
                            updateWeightSliders();
                        }
                    }
                });
            }

            // Class selector change
            weightClassSelect.addEventListener('change', () => {
                updateWeightSliders();
            });

            // Advanced resists checkbox
            const advancedResistsCheckbox = document.getElementById('advancedResists');
            if (advancedResistsCheckbox) {
                // Load saved preference
                const savedAdvancedResists = localStorage.getItem('advancedResists');
                if (savedAdvancedResists !== null) {
                    advancedResists = savedAdvancedResists === 'true';
                    advancedResistsCheckbox.checked = advancedResists;
                }
                
                advancedResistsCheckbox.addEventListener('change', () => {
                    advancedResists = advancedResistsCheckbox.checked;
                    localStorage.setItem('advancedResists', advancedResists.toString());
                });
            }

            // Apply weights button
            const applyBtn = document.getElementById('applyWeights');
            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    saveWeightValues();
                    applyCustomWeights();
                    recalculateScores();
                    filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                });
            }

            // Reset weights button
            const resetBtn = document.getElementById('resetWeights');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    const selectedClass = document.getElementById('weightClass').value;
                    if (selectedClass && customWeights[selectedClass]) {
                        delete customWeights[selectedClass];
                        saveCustomWeights();
                        // Restore original weights
                        if (originalClassWeights[selectedClass]) {
                            classWeights[selectedClass] = JSON.parse(JSON.stringify(originalClassWeights[selectedClass]));
                        }
                        updateWeightSliders();
                        recalculateScores();
                        filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                    } else if (!selectedClass) {
                        // Reset all
                        customWeights = {};
                        saveCustomWeights();
                        classWeights = JSON.parse(JSON.stringify(originalClassWeights));
                        updateWeightSliders();
                        recalculateScores();
                        filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                    }
                });
            }
        }

        function updateWeightSliders() {
            const selectedClass = document.getElementById('weightClass')?.value;
            const slidersDiv = document.getElementById('weightSliders');
            if (!slidersDiv) return;
            
            slidersDiv.innerHTML = '';

            if (!selectedClass) {
                slidersDiv.innerHTML = '<p style="color: #6c757d;">Select a class to customize weights</p>';
                return;
            }

            const weights = classWeights[selectedClass] || {};
            const statKeys = [
                { key: 'hp_pct', label: 'HP', default: 1.0 },
                { key: 'mana_pct', label: 'Mana', default: 1.0 },
                { key: 'ac_pct', label: 'AC', default: 1.0 },
                { key: 'atk_pct', label: 'ATK', default: 1.0 },
                { key: 'haste_pct', label: 'Haste', default: 1.0 },
                { key: 'resists_pct', label: 'Resists', default: 1.0 }
            ];

            statKeys.forEach(stat => {
                const currentValue = weights[stat.key] || stat.default;
                const sliderDiv = document.createElement('div');
                sliderDiv.style.padding = '10px';
                sliderDiv.style.background = 'white';
                sliderDiv.style.borderRadius = '4px';
                sliderDiv.innerHTML = `
                    <label style="display: block; margin-bottom: 5px;">
                        <strong>${stat.label}:</strong> 
                        <span id="value_${stat.key}">${currentValue.toFixed(2)}</span>
                    </label>
                    <input type="range" 
                           id="slider_${stat.key}" 
                           min="0" 
                           max="3" 
                           step="0.1" 
                           value="${currentValue}" 
                           style="width: 100%;"
                           oninput="document.getElementById('value_${stat.key}').textContent = parseFloat(this.value).toFixed(2)">
                `;
                slidersDiv.appendChild(sliderDiv);
            });

            // Focus weight multiplier (2.4x HP weight)
            const hpWeight = weights.hp_pct || 1.0;
            const focusMultiplier = customWeights[selectedClass]?._meta?.focusMultiplier || 2.4;
            const sliderDiv = document.createElement('div');
            sliderDiv.style.padding = '10px';
            sliderDiv.style.background = 'white';
            sliderDiv.style.borderRadius = '4px';
            sliderDiv.innerHTML = `
                <label style="display: block; margin-bottom: 5px;">
                    <strong>Focus Weight Multiplier:</strong> 
                    <span id="value_focus_mult">${focusMultiplier.toFixed(1)}</span>
                    <span style="color: #6c757d; font-size: 0.9em;"> (× HP weight)</span>
                </label>
                <input type="range" 
                       id="slider_focus_mult" 
                       min="0" 
                       max="5" 
                       step="0.1" 
                       value="${focusMultiplier}" 
                       style="width: 100%;"
                       oninput="document.getElementById('value_focus_mult').textContent = parseFloat(this.value).toFixed(1)">
                <p style="font-size: 0.85em; color: #6c757d; margin: 5px 0 0 0;">
                    Total focus weight = (HP weight × multiplier). Default: 2.4 (≈40% for casters)
                </p>
            `;
            slidersDiv.appendChild(sliderDiv);
        }

        function saveWeightValues() {
            const selectedClass = document.getElementById('weightClass')?.value;
            if (!selectedClass) return;

            if (!customWeights[selectedClass]) {
                customWeights[selectedClass] = {};
            }

            const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'atk_pct', 'haste_pct', 'resists_pct'];
            statKeys.forEach(key => {
                const slider = document.getElementById(`slider_${key}`);
                if (slider) {
                    customWeights[selectedClass][key] = parseFloat(slider.value);
                }
            });

            // Store focus multiplier separately
            const focusMultSlider = document.getElementById('slider_focus_mult');
            if (focusMultSlider) {
                if (!customWeights[selectedClass]._meta) {
                    customWeights[selectedClass]._meta = {};
                }
                customWeights[selectedClass]._meta.focusMultiplier = parseFloat(focusMultSlider.value);
            }

            saveCustomWeights();
        }

        function calculateResistScore(resistValue) {
            /**
             * Calculate resist score with weight curve:
             * - Full weight (1.0) up to 220
             * - Linearly decreasing weight from 220 to 320 (1.0 to 0.35)
             * - 0.35 weight from 320 to 500
             * - 0 weight above 500
             * 
             * The score percentage is normalized to show actual value (higher resists = higher score %),
             * but the weight decreases above 220 to reflect diminishing returns.
             */
            if (resistValue <= 0) {
                return { score: 0.0, weight: 0.0 };
            }
            
            // Normalize score based on max value of 500 (so 500 = 100%)
            // This shows the actual value proportionally
            const maxResist = 500.0;
            let score = (resistValue / maxResist) * 100.0;
            
            // Calculate weight based on the curve
            let weight;
            if (resistValue <= 220) {
                // Full weight up to 220
                weight = 1.0;
            } else if (resistValue <= 320) {
                // Linear decrease from 220 to 320 (1.0 to 0.35)
                weight = 1.0 - ((resistValue - 220) / 100.0) * 0.65; // Decreases from 1.0 to 0.35
            } else if (resistValue <= 500) {
                // 0.35 weight from 320 to 500
                weight = 0.35;
            } else {
                // 0 weight above 500
                weight = 0.0;
                score = 0.0; // No score above 500
            }
            
            return { score: score, weight: weight };
        }

        function normalizeWeights(weights, focusMultiplier = 2.4) {
            const hpWeight = weights.hp_pct || 0.0;
            const focusWeights = weights.focus || {};
            
            let totalFocusWeightConfig = 0.0;
            for (const [focusCat, focusValue] of Object.entries(focusWeights)) {
                if (typeof focusValue === 'object') {
                    totalFocusWeightConfig += Object.values(focusValue).reduce((a, b) => a + b, 0);
                } else {
                    totalFocusWeightConfig += focusValue;
                }
            }

            // Only calculate focus scale if HP weight > 0 and we have focus weights
            const focusScale = (hpWeight > 0 && totalFocusWeightConfig > 0) ? (focusMultiplier * hpWeight) / totalFocusWeightConfig : 0.0;

            let totalWeight = 0.0;
            const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'atk_pct', 'haste_pct', 'resists_pct'];
            statKeys.forEach(key => {
                totalWeight += weights[key] || 0.0;
            });

            // Only add focus weights if HP > 0 (focuses are based on HP weight)
            if (hpWeight > 0 && focusWeights && focusScale > 0) {
                for (const [focusCat, focusValue] of Object.entries(focusWeights)) {
                    if (typeof focusValue === 'object') {
                        totalWeight += Object.values(focusValue).reduce((a, b) => a + b, 0) * focusScale;
                    } else {
                        totalWeight += focusValue * focusScale;
                    }
                }
            }

            const normalized = {};
            if (totalWeight > 0) {
                statKeys.forEach(key => {
                    normalized[key] = (weights[key] || 0.0) / totalWeight;
                });
                
                normalized.focus = {};
                if (hpWeight > 0 && focusWeights && focusScale > 0) {
                    for (const [focusCat, focusValue] of Object.entries(focusWeights)) {
                        if (typeof focusValue === 'object') {
                            normalized.focus[focusCat] = {};
                            for (const [damageType, weight] of Object.entries(focusValue)) {
                                normalized.focus[focusCat][damageType] = (weight * focusScale) / totalWeight;
                            }
                        } else {
                            normalized.focus[focusCat] = (focusValue * focusScale) / totalWeight;
                        }
                    }
                }
            } else {
                // If totalWeight is 0, return weights as-is (they're already normalized to 0)
                statKeys.forEach(key => {
                    normalized[key] = 0.0;
                });
                normalized.focus = {};
            }

            return normalized;
        }

        function recalculateScores() {
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass || !classWeights[charClass]) return;

                const customWeight = customWeights[charClass] || {};
                const focusMultiplier = customWeight._meta?.focusMultiplier || 2.4;
                
                let weights = JSON.parse(JSON.stringify(originalClassWeights[charClass] || classWeights[charClass]));
                
                Object.keys(customWeight).forEach(key => {
                    if (key !== '_meta' && weights.hasOwnProperty(key)) {
                        weights[key] = customWeight[key];
                    }
                });

                const normalized = normalizeWeights(weights, focusMultiplier);
                const scores = char.scores || {};
                let totalScore = 0.0;
                let totalWeight = 0.0;

                if (scores.hp_pct !== undefined && normalized.hp_pct > 0) {
                    totalScore += scores.hp_pct * normalized.hp_pct;
                    totalWeight += normalized.hp_pct;
                }
                if (scores.mana_pct !== undefined && normalized.mana_pct > 0) {
                    totalScore += scores.mana_pct * normalized.mana_pct;
                    totalWeight += normalized.mana_pct;
                }
                if (scores.ac_pct !== undefined && normalized.ac_pct > 0) {
                    totalScore += scores.ac_pct * normalized.ac_pct;
                    totalWeight += normalized.ac_pct;
                }
                if (scores.atk_pct !== undefined && normalized.atk_pct > 0) {
                    totalScore += scores.atk_pct * normalized.atk_pct;
                    totalWeight += normalized.atk_pct;
                }
                if (scores.haste_pct !== undefined && normalized.haste_pct > 0) {
                    totalScore += scores.haste_pct * normalized.haste_pct;
                    totalWeight += normalized.haste_pct;
                }
                // Resists - use advanced resists if enabled
                if (scores.resists_pct !== undefined && normalized.resists_pct > 0) {
                    if (advancedResists && char.individual_resists) {
                        // Calculate individual resist scores with weight curve
                        let totalResistScore = 0.0;
                        let totalResistWeight = 0.0;
                        
                        const resistTypes = ['MR', 'FR', 'CR', 'DR', 'PR'];
                        resistTypes.forEach(resistType => {
                            const resistValue = char.individual_resists[resistType] || 0;
                            const { score, weight } = calculateResistScore(resistValue);
                            totalResistScore += score * weight;
                            totalResistWeight += weight;
                        });
                        
                        if (totalResistWeight > 0) {
                            const avgResistScore = totalResistScore / totalResistWeight;
                            totalScore += avgResistScore * normalized.resists_pct;
                            totalWeight += normalized.resists_pct;
                        }
                    } else {
                        // Use simple total resists percentage
                        totalScore += scores.resists_pct * normalized.resists_pct;
                        totalWeight += normalized.resists_pct;
                    }
                }
                // FT is only included if HP weight > 0 (FT is tied to HP/mana for casters)
                // Check if any stat weight is set (not just HP) to determine if FT should be included
                const hasStatWeights = normalized.hp_pct > 0 || normalized.mana_pct > 0 || normalized.ac_pct > 0 || 
                                      normalized.atk_pct > 0 || normalized.haste_pct > 0 || normalized.resists_pct > 0;
                if (scores.ft_capped === true && hasStatWeights) {
                    // FT weight is 2.0, but we need to normalize it against the total
                    // For now, only include FT if HP or Mana has weight (FT is for casters)
                    if (normalized.hp_pct > 0 || normalized.mana_pct > 0) {
                        totalScore += 100.0 * 2.0;
                        totalWeight += 2.0;
                    }
                }

                const focusWeights = normalized.focus || {};
                if (Object.keys(focusWeights).length > 0 && scores.focus_overall_pct !== undefined) {
                    let totalFocusWeight = 0.0;
                    for (const weight of Object.values(focusWeights)) {
                        if (typeof weight === 'object') {
                            totalFocusWeight += Object.values(weight).reduce((a, b) => a + b, 0);
                        } else {
                            totalFocusWeight += weight;
                        }
                    }
                    if (totalFocusWeight > 0) {
                        totalScore += scores.focus_overall_pct * totalFocusWeight;
                        totalWeight += totalFocusWeight;
                    }
                }

                char.overall_score = totalWeight > 0 ? (totalScore / totalWeight) : 0;
            });

            // Sort by overall score for overall ranking
            characters.sort((a, b) => (b.overall_score || 0) - (a.overall_score || 0));
            
            // Calculate overall ranks
            let overallRank = 1;
            characters.forEach((char, index) => {
                if (index === 0 || characters[index - 1].overall_score !== char.overall_score) {
                    overallRank = index + 1;
                }
                char.overall_rank = overallRank;
            });
            
            // Calculate class ranks separately - group by class, sort each group, then assign ranks
            const charactersByClass = {};
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass) return;
                if (!charactersByClass[charClass]) {
                    charactersByClass[charClass] = [];
                }
                charactersByClass[charClass].push(char);
            });
            
            // Sort each class by overall_score and assign class ranks
            Object.keys(charactersByClass).forEach(charClass => {
                const classChars = charactersByClass[charClass];
                classChars.sort((a, b) => (b.overall_score || 0) - (a.overall_score || 0));
                
                let classRank = 1;
                classChars.forEach((char, index) => {
                    if (index === 0 || classChars[index - 1].overall_score !== char.overall_score) {
                        classRank = index + 1;
                    }
                    char.class_rank = classRank;
                });
            });
        }
        
        async function loadData() {
            try {
                // Try multiple possible paths for GitHub Pages
                const possiblePaths = [
                    'class_rankings.json',  // Same directory
                    './class_rankings.json',  // Explicit same directory
                    '/class_rankings.json',  // Root path
                    window.location.pathname.replace(/\/[^/]*$/, '/') + 'class_rankings.json',  // Same directory as HTML
                ];
                
                // Add repository path if on GitHub Pages
                const repoMatch = window.location.pathname.match(/^\/[^/]+\/[^/]+/);
                if (repoMatch) {
                    possiblePaths.push(repoMatch[0] + '/class_rankings.json');
                }
                
                let jsonPath = '';
                let response = null;
                let lastError = null;
                
                for (const path of possiblePaths) {
                    try {
                        console.log(`Trying to load from: ${path}`);
                        response = await fetch(path);
                        if (response.ok) {
                            jsonPath = path;
                            console.log(`✓ Successfully loaded from: ${path}`);
                            break;
                        } else {
                            console.log(`✗ Failed to load from ${path}: ${response.status}`);
                            lastError = `HTTP ${response.status} from ${path}`;
                        }
                    } catch (e) {
                        console.log(`✗ Error loading from ${path}:`, e.message);
                        lastError = e.message;
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error(`Could not load class_rankings.json from any path. Last error: ${lastError}. Tried: ${possiblePaths.join(', ')}`);
                }
                
                const data = await response.json();
                // Handle both old format (array) and new format (object with characters)
                if (Array.isArray(data)) {
                    characters = data;
                } else {
                    characters = data.characters || [];
                    classWeights = data.class_weights || {};
                    originalClassWeights = JSON.parse(JSON.stringify(classWeights)); // Deep copy
                }
                filteredCharacters = [...characters];
                
                // Load custom weights from localStorage
                loadCustomWeights();
                
                populateFilters();
                setupWeightControls();
                renderTable();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('rankingsTable').style.display = 'table';
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                console.error('Error:', error);
            }
        }

        function populateFilters() {
            const classes = new Set(characters.map(c => c.class).filter(c => c));
            const classSelect = document.getElementById('filterClass');
            
            [...classes].sort().forEach(cls => {
                const option = document.createElement('option');
                option.value = cls;
                option.textContent = cls;
                classSelect.appendChild(option);
            });
        }

        function filterAndSort() {
            filteredCharacters = characters.filter(char => {
                if (filterClass && char.class !== filterClass) return false;
                return true;
            });
            
            filteredCharacters.sort((a, b) => {
                if (sortBy === 'overall') return b.overall_score - a.overall_score;
                if (sortBy === 'class_rank') {
                    if (a.class !== b.class) return a.class.localeCompare(b.class);
                    return a.class_rank - b.class_rank;
                }
                if (sortBy === 'hp') return (b.stats.hp || 0) - (a.stats.hp || 0);
                if (sortBy === 'mana') return (b.stats.mana || 0) - (a.stats.mana || 0);
                if (sortBy === 'ac') return (b.stats.ac || 0) - (a.stats.ac || 0);
                if (sortBy === 'atk') {
                    const aAtk = parseInt(a.stats.atk_item?.split(' / ')[0] || '0');
                    const bAtk = parseInt(b.stats.atk_item?.split(' / ')[0] || '0');
                    return bAtk - aAtk;
                }
                if (sortBy === 'resists') return (b.scores.resists || 0) - (a.scores.resists || 0);
                if (sortBy === 'focus') return (b.scores.focus_overall_pct || 0) - (a.scores.focus_overall_pct || 0);
                return 0;
            });
            
            renderTable();
        }

        function getScoreClass(score) {
            if (score >= 90) return 'high';
            if (score >= 70) return 'medium';
            return 'low';
        }

        function formatScore(score) {
            if (score === null || score === undefined) return 'N/A';
            return score.toFixed(1) + '%';
        }

        function renderTable() {
            const tbody = document.getElementById('rankingsBody');
            tbody.innerHTML = '';
            
            filteredCharacters.forEach((char, index) => {
                const row = document.createElement('tr');
                const scores = char.scores;
                const focii = char.focii || {};
                
                // Get spell damage score (class-specific)
                const spellDmgScore = scores.focus_scores && scores.focus_scores['Spell Damage'] 
                    ? scores.focus_scores['Spell Damage'] 
                    : null;
                
                // Get class-specific weight configuration
                const charClass = char.class || '';
                const classWeightConfig = classWeights[charClass] || {};
                const focusWeights = classWeightConfig.focus || {};
                const spellDamageWeights = focusWeights['Spell Damage'] || {};
                
                // Special handling for Warriors and Pal/SK - show focus items status
                let damageBadges = '';
                let otherBadges = '';
                
                if (charClass === 'Warrior') {
                    // For Warriors, show individual focus items in Damage Types column
                    const focusItems = scores.focus_items || {};
                    const badges = [];
                    if (focusItems.has_mh) {
                        badges.push('<span class="focus-badge" title="Darkblade of the Warlord">Darkblade</span>');
                    }
                    if (focusItems.has_chest) {
                        badges.push('<span class="focus-badge" title="Raex\'s Chestplate of Destruction">Raex Chest</span>');
                    }
                    if (focusItems.has_haste) {
                        badges.push('<span class="focus-badge" title="Max Haste (100%)">Haste ✓</span>');
                    }
                    damageBadges = badges.length > 0 ? badges.join(' ') : '<span style="color: #6c757d;">-</span>';
                    otherBadges = '<span style="color: #6c757d;">-</span>'; // Warriors don't have other focii
                } else if (charClass === 'Paladin' || charClass === 'Shadow Knight') {
                    // For Pal/SK, show Shield of Strife
                    const focusItems = scores.focus_items || {};
                    if (focusItems.has_shield) {
                        damageBadges = '<span class="focus-badge" title="Shield of Strife">Shield of Strife ✓</span>';
                    } else {
                        damageBadges = '<span class="focus-badge" style="opacity: 0.3;">No Shield</span>';
                    }
                    otherBadges = ''; // Pal/SK don't have other focii
                } else {
                    // Check if this is a pure melee class (no caster focuses)
                    const pureMeleeClasses = ['Warrior', 'Monk', 'Rogue'];
                    const isPureMelee = pureMeleeClasses.includes(charClass);
                    
                    if (isPureMelee) {
                        // Pure melees don't have caster focuses
                        damageBadges = '<span style="color: #6c757d;">-</span>';
                        otherBadges = '<span style="color: #6c757d;">-</span>';
                    } else {
                        // Get damage-specific focii - show all damage types the character has
                        // (even if not weighted, so users can see what they have)
                        const damageFocii = char.damage_focii || {};
                        const allDamageFocii = Object.entries(damageFocii)
                            .sort((a, b) => b[1] - a[1]);
                        
                        // Highlight weighted damage types, show others too
                        damageBadges = allDamageFocii
                            .map(([type, pct]) => {
                                const isWeighted = spellDamageWeights.hasOwnProperty(type);
                                const weight = spellDamageWeights[type] || 0;
                                const title = isWeighted 
                                    ? `${type} Damage: ${pct}% (weighted: ${weight})`
                                    : `${type} Damage: ${pct}% (not weighted for ${charClass})`;
                                const style = isWeighted ? '' : 'opacity: 0.6;';
                                return `<span class="focus-badge" title="${title}" style="${style}">${type} ${pct}%</span>`;
                            }).join('');
                        
                        // Get other focii - show all focii the character has
                        // Highlight weighted ones, show others with reduced opacity
                        const relevantFocusCats = Object.keys(focusWeights).filter(cat => cat !== 'Spell Damage');
                        
                        // Build focus display with categories
                        const focusDisplay = [];
                    
                    // Helper function to format focus with category
                    const formatFocusWithCategory = (baseName, category, pct, isWeighted, weight) => {
                        const catAbbrev = {
                            'Det': 'Det',
                            'Bene': 'Bene',
                            'Nuke': '',
                            'Sanguine': 'Sanguine',
                            'All': 'All'
                        }[category] || '';
                        
                        // Format: "Bene Spell Haste 30%" or "Mana Efficiency 25%" (no prefix for Nuke)
                        let displayName = baseName;
                        if (catAbbrev) {
                            displayName = `${catAbbrev} ${baseName}`;
                        }
                        
                        const title = isWeighted 
                            ? `${baseName} (${category}): ${pct}% (weighted: ${weight})`
                            : `${baseName} (${category}): ${pct}% (not weighted for ${charClass})`;
                        const style = isWeighted ? '' : 'opacity: 0.6;';
                        return `<span class="focus-badge" title="${title}" style="${style}">${displayName} ${pct}%</span>`;
                    };
                    
                    // Handle Mana Efficiency with categories
                    if (focii['Spell Mana Efficiency'] > 0) {
                        const manaEffCats = char.mana_efficiency_cats || {};
                        Object.entries(manaEffCats).sort((a, b) => b[1] - a[1]).forEach(([cat, pct]) => {
                            // Skip Sanguine (self-only) - don't display it
                            if (cat === 'Sanguine') return;
                            
                            const isWeighted = relevantFocusCats.includes('Spell Mana Efficiency');
                            const weight = focusWeights['Spell Mana Efficiency'] || 0;
                            // For Nuke, show "Mana Efficiency" (no prefix), others show category prefix
                            const baseName = 'Mana Efficiency';
                            focusDisplay.push(formatFocusWithCategory(baseName, cat, pct, isWeighted, weight));
                        });
                    }
                    
                    // Handle Spell Haste with categories
                    if (focii['Spell Haste'] > 0) {
                        const hasteCats = char.spell_haste_cats || {};
                        Object.entries(hasteCats).sort((a, b) => b[1] - a[1]).forEach(([cat, pct]) => {
                            // Check for specific haste category weight: 'Bene' -> 'Beneficial Spell Haste', 'Det' -> 'Detrimental Spell Haste'
                            const hasteWeightKey = cat === 'Bene' ? 'Beneficial Spell Haste' : 'Detrimental Spell Haste';
                            const isWeighted = relevantFocusCats.includes(hasteWeightKey);
                            const weight = focusWeights[hasteWeightKey] || 0;
                            focusDisplay.push(formatFocusWithCategory('Spell Haste', cat, pct, isWeighted, weight));
                        });
                    }
                    
                    // Handle Duration with categories
                    // Only show relevant categories for each duration type to avoid duplicates
                    if (focii['Buff Spell Duration'] > 0) {
                        const durCats = char.duration_cats || {};
                        // Buff Spell Duration: show 'Bene' and 'All' only
                        ['Bene', 'All'].forEach(cat => {
                            if (durCats[cat] !== undefined && durCats[cat] > 0) {
                                const isWeighted = relevantFocusCats.includes('Buff Spell Duration');
                                const weight = focusWeights['Buff Spell Duration'] || 0;
                                const displayCat = cat === 'All' ? 'All' : 'Bene';
                                focusDisplay.push(formatFocusWithCategory('Duration', displayCat, durCats[cat], isWeighted, weight));
                            }
                        });
                    }
                    if (focii['Detrimental Spell Duration'] > 0) {
                        const durCats = char.duration_cats || {};
                        // Detrimental Spell Duration: show 'Det' and 'All' only
                        ['Det', 'All'].forEach(cat => {
                            if (durCats[cat] !== undefined && durCats[cat] > 0) {
                                const isWeighted = relevantFocusCats.includes('Detrimental Spell Duration');
                                const weight = focusWeights['Detrimental Spell Duration'] || 0;
                                const displayCat = cat === 'All' ? 'All' : 'Det';
                                focusDisplay.push(formatFocusWithCategory('Duration', displayCat, durCats[cat], isWeighted, weight));
                            }
                        });
                    }
                    if (focii['All Spell Duration'] > 0) {
                        const durCats = char.duration_cats || {};
                        // All Spell Duration: show 'All' only
                        if (durCats['All'] !== undefined && durCats['All'] > 0) {
                            const isWeighted = relevantFocusCats.includes('All Spell Duration');
                            const weight = focusWeights['All Spell Duration'] || 0;
                            focusDisplay.push(formatFocusWithCategory('Duration', 'All', durCats['All'], isWeighted, weight));
                        }
                    }
                    
                    // Handle other focii (Healing Enhancement, Range Extension, etc.)
                    const otherFocii = Object.entries(focii)
                        .filter(([cat]) => !['Spell Damage', 'Spell Mana Efficiency', 'Spell Haste', 
                                             'Buff Spell Duration', 'Detrimental Spell Duration', 'All Spell Duration'].includes(cat))
                        .sort((a, b) => {
                            const aWeighted = relevantFocusCats.includes(a[0]);
                            const bWeighted = relevantFocusCats.includes(b[0]);
                            if (aWeighted && !bWeighted) return -1;
                            if (!aWeighted && bWeighted) return 1;
                            return b[1] - a[1];
                        });
                    
                    otherFocii.forEach(([cat, pct]) => {
                        const isWeighted = relevantFocusCats.includes(cat);
                        const weight = focusWeights[cat] || 0;
                        // Shorten names: "Healing Enhancement" -> "Healing", "Range Extension" -> "Range Ext"
                        let shortName = cat.replace('Spell ', '');
                        if (shortName === 'Healing Enhancement') shortName = 'Healing';
                        else if (shortName === 'Spell Range Extension') shortName = 'Range Ext';
                        const title = isWeighted 
                            ? `${cat}: ${pct}% (weighted: ${weight})`
                            : `${cat}: ${pct}% (not weighted for ${charClass})`;
                        const style = isWeighted ? '' : 'opacity: 0.6;';
                        focusDisplay.push(`<span class="focus-badge" title="${title}" style="${style}">${shortName} ${pct}%</span>`);
                    });
                    
                        // Join with commas and spaces
                        otherBadges = focusDisplay.length > 0 ? focusDisplay.join(', ') : '<span style="color: #6c757d;">-</span>';
                    }
                }
                
                // Format actual stat values
                const formatStat = (value, statName) => {
                    if (value === null || value === undefined) {
                        if (statName === 'ac') return '0';  // AC defaults to 0 if missing
                        return 'N/A';
                    }
                    if (statName === 'haste') {
                        // Haste is binary: show "100% ✓" if max (30% item = 100% total), otherwise actual item value
                        // Get haste_value from scores, not from the value parameter
                        const hasteValue = scores.haste_value;
                        if (hasteValue === null || hasteValue === undefined) return 'N/A';
                        // Check if it's actually a number, not a string like "255 / 250"
                        if (typeof hasteValue === 'number') {
                            return hasteValue >= 30 ? '100% ✓' : `${hasteValue}%`;
                        }
                        return 'N/A';
                    }
                    if (statName === 'atk') {
                        // ATK shows as "current / 250"
                        if (typeof value === 'string' && value.includes(' / ')) {
                            return value;
                        }
                        return value || '0 / 250';
                    }
                    if (statName === 'ac') {
                        // AC - ensure we convert to number and format properly
                        const acValue = typeof value === 'number' ? value : parseInt(value) || 0;
                        return acValue.toLocaleString();
                    }
                    // For other stats, convert to number if needed and format
                    const numValue = typeof value === 'number' ? value : (parseInt(value) || 0);
                    return numValue.toLocaleString();
                };
                
                // Build row cells in exact order matching headers
                const cells = [];
                
                // Rank, Class Rank, Name, Guild, Class, Overall (fixed columns - indices 0-5)
                cells.push(`<td class="rank">#${char.overall_rank || index + 1}</td>`);
                cells.push(`<td class="rank">#${char.class_rank || '-'}</td>`);
                cells.push(`<td class="name"><a href="https://www.takproject.net/magelo/character.php?char=${encodeURIComponent(char.name)}" target="_blank">${escapeHtml(char.name)}</a></td>`);
                cells.push(`<td>${escapeHtml(char.guild || '')}</td>`);
                cells.push(`<td>${escapeHtml(char.class || '')}</td>`);
                cells.push(`<td class="score ${getScoreClass(char.overall_score)}">${formatScore(char.overall_score)}</td>`);
                
                // Stat columns (in header order - indices 6-10)
                // Index 6: HP
                cells.push(`<td class="stat-col" data-stat="hp">${formatStat(char.stats.hp, 'hp')}</td>`);
                // Index 7: Mana
                cells.push(`<td class="stat-col" data-stat="mana">${formatStat(char.stats.mana, 'mana')}</td>`);
                // Index 8: AC - check both stats.ac and scores.ac, ensure it's a number
                const acValue = (char.stats.ac !== undefined && char.stats.ac !== null) 
                    ? (typeof char.stats.ac === 'number' ? char.stats.ac : parseInt(char.stats.ac) || 0)
                    : ((scores.ac !== undefined && scores.ac !== null) 
                        ? (typeof scores.ac === 'number' ? scores.ac : parseInt(scores.ac) || 0)
                        : 0);
                cells.push(`<td class="stat-col" data-stat="ac">${acValue.toLocaleString()}</td>`);
                // Index 9: ATK
                cells.push(`<td class="stat-col" data-stat="atk">${formatStat(char.stats.atk_item, 'atk')}</td>`);
                // Index 10: Resists - total resists value
                const resistsValue = scores.resists !== null && scores.resists !== undefined ? scores.resists : 0;
                const resistsDisplay = resistsValue > 0 ? resistsValue.toLocaleString() : 'N/A';
                cells.push(`<td class="stat-col" data-stat="resists">${resistsDisplay}</td>`);
                
                // Focus %, Spell Dmg %, Damage Types, Other Focii (fixed columns - indices 11-14)
                // IMPORTANT: Always create all 15 cells in exact header order to maintain alignment
                cells.push(`<td class="score">${formatScore(scores.focus_overall_pct)}</td>`);  // Index 11: Focus %
                cells.push(`<td class="stat-col score ${spellDmgScore !== null ? getScoreClass(spellDmgScore) : ''}" data-stat="spelldmg">${formatScore(spellDmgScore)}</td>`);  // Index 12: Spell Dmg %
                // Damage Types - ensure we're using the badges, not a score
                const damageTypesDisplay = damageBadges || '<span style="color: #6c757d;">-</span>';
                cells.push(`<td>${damageTypesDisplay}</td>`);  // Index 13: Damage Types
                // Other Focii - ensure we're using the badges, not a score
                const otherFociiDisplay = otherBadges || '<span style="color: #6c757d;">-</span>';
                cells.push(`<td>${otherFociiDisplay}</td>`);  // Index 14: Other Focii
                
                // Verify we have exactly 15 cells (matching 15 headers)
                if (cells.length !== 15) {
                    console.error(`Row for ${char.name} has ${cells.length} cells, expected 15`);
                    console.error('Cells:', cells.map((c, i) => `${i}: ${c.substring(0, 50)}`));
                }
                
                // Debug: Log first few rows to verify column alignment
                if (index < 3) {
                    console.log(`Row ${index} (${char.name}):`, {
                        ac: acValue,
                        haste: scores.haste_value,
                        damageBadges: damageBadges.substring(0, 50),
                        otherBadges: otherBadges.substring(0, 50),
                        cellCount: cells.length
                    });
                }
                
                row.innerHTML = cells.join('');
                row.classList.add('clickable-row');
                row.addEventListener('click', (e) => {
                    // Don't trigger if clicking on a link
                    if (e.target.tagName !== 'A') {
                        showScoreBreakdown(char);
                    }
                });
                
                tbody.appendChild(row);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.getElementById('filterClass').addEventListener('change', (e) => {
            filterClass = e.target.value;
            filterAndSort();
        });

        document.getElementById('sortBy').addEventListener('change', (e) => {
            sortBy = e.target.value;
            filterAndSort();
        });

        // Modal functionality
        const modal = document.getElementById('scoreModal');
        const closeBtn = document.getElementsByClassName('close')[0];

        closeBtn.onclick = function() {
            modal.style.display = 'none';
        };

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };

        function showScoreBreakdown(char) {
            const modal = document.getElementById('scoreModal');
            const modalContent = document.getElementById('modalContent');
            const scores = char.scores || {};
            const classWeightConfig = classWeights[char.class] || {};
            const focusWeights = classWeightConfig.focus || {};
            
            let html = `<h2>${escapeHtml(char.name)} (${escapeHtml(char.class)})</h2>`;
            html += `<p><a href="https://www.takproject.net/magelo/character.php?char=${encodeURIComponent(char.name)}" target="_blank">View on Magelo</a></p>`;
            html += `<div class="score-breakdown">`;
            
            // Overall Score
            html += `<h3>Overall Score: ${formatScore(char.overall_score)}</h3>`;
            
            // Stat Scores
            html += `<h3>Stat Scores</h3>`;
            html += `<table><thead><tr><th>Stat</th><th>Value</th><th>Score %</th><th>Weight</th></tr></thead><tbody>`;
            
            // HP - check for hp_pct first, then calculate if needed
            if (scores.hp !== undefined && scores.hp !== null || scores.hp_pct !== undefined) {
                const weight = classWeightConfig.hp_pct || 0;
                const hpValue = char.stats.hp || 0;
                const hpPct = scores.hp_pct !== undefined && scores.hp_pct !== null ? scores.hp_pct : 'N/A';
                html += `<tr><td>HP</td><td>${hpValue.toLocaleString()}</td><td>${formatScore(hpPct)}</td><td>${weight.toFixed(2)}</td></tr>`;
            }
            
            // Mana - check for mana_pct first
            if (scores.mana !== undefined && scores.mana !== null || scores.mana_pct !== undefined) {
                const weight = classWeightConfig.mana_pct || 0;
                const manaValue = char.stats.mana || 0;
                const manaPct = scores.mana_pct !== undefined && scores.mana_pct !== null ? scores.mana_pct : 'N/A';
                html += `<tr><td>Mana</td><td>${manaValue.toLocaleString()}</td><td>${formatScore(manaPct)}</td><td>${weight.toFixed(2)}</td></tr>`;
            }
            
            // AC - check for ac_pct first
            if (scores.ac !== undefined && scores.ac !== null || scores.ac_pct !== undefined) {
                const weight = classWeightConfig.ac_pct || 0;
                const acValue = scores.ac !== undefined && scores.ac !== null ? scores.ac : (char.stats.ac || 0);
                const acPct = scores.ac_pct !== undefined && scores.ac_pct !== null ? scores.ac_pct : 'N/A';
                html += `<tr><td>AC</td><td>${acValue.toLocaleString()}</td><td>${formatScore(acPct)}</td><td>${weight.toFixed(2)}</td></tr>`;
            }
            
            // ATK
            if (scores.atk_pct !== undefined && scores.atk_pct !== null) {
                const weight = classWeightConfig.atk_pct || 0;
                html += `<tr><td>ATK</td><td>${char.stats.atk_item || 'N/A'}</td><td>${formatScore(scores.atk_pct)}</td><td>${weight.toFixed(2)}</td></tr>`;
            }
            
            // Resists - show individual resists if available and advanced mode is on
            if (scores.resists !== undefined && scores.resists !== null || scores.resists_pct !== undefined) {
                const weight = classWeightConfig.resists_pct || 0;
                const resistsValue = scores.resists !== undefined && scores.resists !== null ? scores.resists : 0;
                const resistsPct = scores.resists_pct !== undefined && scores.resists_pct !== null ? scores.resists_pct : 'N/A';
                
                // Show individual resists if available
                const individualResistScores = scores.individual_resist_scores;
                if (individualResistScores && Object.keys(individualResistScores).length > 0) {
                    html += `<tr><td colspan="4"><strong>Resists (Advanced)</strong></td></tr>`;
                    const resistTypes = ['MR', 'FR', 'CR', 'DR', 'PR'];
                    let totalRawValue = 0;
                    resistTypes.forEach(resistType => {
                        const resistData = individualResistScores[resistType];
                        if (resistData) {
                            totalRawValue += resistData.value;
                            html += `<tr><td style="padding-left: 20px;">${resistType}</td><td>${resistData.value}</td><td>${formatScore(resistData.score)}</td><td>${resistData.weight.toFixed(2)}</td></tr>`;
                        }
                    });
                    html += `<tr><td><strong>Total</strong></td><td><strong>${totalRawValue.toLocaleString()}</strong></td><td><strong>${formatScore(resistsPct)}</strong></td><td><strong>${weight.toFixed(2)}</strong></td></tr>`;
                } else {
                    html += `<tr><td>Resists</td><td>${resistsValue.toLocaleString()}</td><td>${formatScore(resistsPct)}</td><td>${weight.toFixed(2)}</td></tr>`;
                }
            }
            
            // FT (Flowing Thought)
            if (scores.ft_capped === true) {
                html += `<tr><td>FT (Capped)</td><td>15/15</td><td>100%</td><td>2.0</td></tr>`;
            }
            
            html += `</tbody></table>`;
            
            // Focus Scores
            const focusScores = scores.focus_scores || {};
            const charFocii = char.focii || {};
            const charDamageFocii = char.damage_focii || {};
            const charManaEffCats = char.mana_efficiency_cats || {};
            const charSpellHasteCats = char.spell_haste_cats || {};
            const charDurationCats = char.duration_cats || {};
            
            if (Object.keys(focusScores).length > 0) {
                html += `<h3>Focus Scores</h3>`;
                html += `<table><thead><tr><th>Focus</th><th>Raw Value</th><th>Score %</th><th>Weight</th></tr></thead><tbody>`;
                
                // For Warriors/Pal/SK, calculate focus weight as 2.4x HP weight (after normalization)
                // For other classes, use the focus weights from config
                let totalFocusWeight = 0;
                const charClass = char.class || '';
                if (charClass === 'Warrior' || charClass === 'Paladin' || charClass === 'Shadow Knight') {
                    // Calculate normalized weights first
                    // Sum all stat weights
                    let totalStatWeight = 0;
                    const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'atk_pct', 'haste_pct', 'resists_pct'];
                    statKeys.forEach(key => {
                        totalStatWeight += classWeightConfig[key] || 0;
                    });
                    
                    // Calculate total focus weight (2.4x HP weight before normalization)
                    const rawHpWeight = classWeightConfig.hp_pct || 0;
                    const rawFocusWeight = rawHpWeight * 2.4;
                    
                    // Total weight before normalization = stat weights + focus weights
                    const totalRawWeight = totalStatWeight + rawFocusWeight;
                    
                    // Normalized focus weight = (raw focus weight / total raw weight)
                    if (totalRawWeight > 0) {
                        totalFocusWeight = rawFocusWeight / totalRawWeight;
                    }
                } else {
                    // Sum all focus weights (these are already normalized in the JSON)
                    for (const [cat, weight] of Object.entries(focusWeights)) {
                        if (typeof weight === 'object') {
                            totalFocusWeight += Object.values(weight).reduce((a, b) => a + b, 0);
                        } else {
                            totalFocusWeight += weight;
                        }
                    }
                }
                
                // Helper function to get raw value for a focus category
                function getRawFocusValue(focusCat) {
                    if (focusCat === 'Spell Damage') {
                        // Get the best damage type value
                        const damageTypes = Object.keys(charDamageFocii);
                        if (damageTypes.length > 0) {
                            const bestType = damageTypes.reduce((a, b) => charDamageFocii[a] > charDamageFocii[b] ? a : b);
                            return charDamageFocii[bestType] || 0;
                        }
                        return 0;
                    } else if (focusCat === 'Spell Mana Efficiency') {
                        // Get the best mana efficiency category
                        const cats = Object.keys(charManaEffCats);
                        if (cats.length > 0) {
                            const bestCat = cats.reduce((a, b) => charManaEffCats[a] > charManaEffCats[b] ? a : b);
                            return charManaEffCats[bestCat] || 0;
                        }
                        return 0;
                    } else if (focusCat === 'Beneficial Spell Haste' || focusCat === 'Detrimental Spell Haste') {
                        const hasteCat = focusCat === 'Beneficial Spell Haste' ? 'Bene' : 'Det';
                        return charSpellHasteCats[hasteCat] || 0;
                    } else if (focusCat === 'Buff Spell Duration' || focusCat === 'Beneficial Spell Duration') {
                        return charDurationCats['Bene'] || 0;
                    } else if (focusCat === 'Detrimental Spell Duration') {
                        return charDurationCats['Det'] || 0;
                    } else if (focusCat === 'All Spell Duration') {
                        return charDurationCats['All'] || 0;
                    } else if (focusCat === 'Haste') {
                        // Haste is binary, show the item haste value
                        const hasteValue = char.stats?.haste || 0;
                        return hasteValue >= 30 ? 30 : hasteValue;
                    } else {
                        // For other focuses, get from charFocii
                        return charFocii[focusCat] || 0;
                    }
                }
                
                for (const [focusCat, score] of Object.entries(focusScores)) {
                    let weight = 0;
                    let rawValue = getRawFocusValue(focusCat);
                    
                    if (focusCat === 'Spell Damage') {
                        // Spell Damage has nested weights
                        const damageWeights = focusWeights['Spell Damage'] || {};
                        weight = Object.values(damageWeights).reduce((a, b) => a + b, 0);
                    } else if (focusCat === 'Haste') {
                        weight = 1.0; // Haste is binary, weight is 1
                    } else if (focusCat === 'Warrior Focus Items' || focusCat === 'Shield of Strife' || focusCat === 'Serpent of Vindication') {
                        // For Warriors/Pal/SK/Enchanter, use the calculated total focus weight
                        weight = totalFocusWeight;
                        // These are binary (100 or 0), so raw value is the score
                        rawValue = score === 100 ? 100 : 0;
                    } else {
                        weight = focusWeights[focusCat] || 0;
                    }
                    
                    // Format raw value
                    let rawDisplay = 'N/A';
                    if (rawValue > 0) {
                        if (focusCat === 'Haste') {
                            rawDisplay = `${rawValue}% (${rawValue >= 30 ? 'Capped' : 'Not Capped'})`;
                        } else {
                            rawDisplay = `${rawValue.toFixed(1)}%`;
                        }
                    }
                    
                    html += `<tr><td>${escapeHtml(focusCat)}</td><td>${rawDisplay}</td><td>${formatScore(score)}</td><td>${weight.toFixed(2)}</td></tr>`;
                }
                
                html += `</tbody></table>`;
            }
            
            // Gear display with item links
            if (char.inventory && char.inventory.length > 0) {
                html += `<h3>Equipped Gear</h3>`;
                html += `<div style="display: flex; flex-wrap: wrap; gap: 10px;">`;
                const slotNames = {
                    0: 'Charm', 1: 'Ear', 2: 'Head', 3: 'Face', 4: 'Ear', 5: 'Neck',
                    6: 'Shoulder', 7: 'Arms', 8: 'Back', 9: 'Wrist', 10: 'Wrist',
                    11: 'Range', 12: 'Hands', 13: 'Main Hand', 14: 'Off Hand',
                    15: 'Primary', 16: 'Secondary', 17: 'Chest', 18: 'Legs',
                    19: 'Feet', 20: 'Waist', 21: 'Power Source', 22: 'Ammo'
                };
                char.inventory.forEach(item => {
                    const slotName = slotNames[item.slot_id] || `Slot ${item.slot_id}`;
                    const itemLink = `<a href="https://www.takproject.net/allaclone/item.php?id=${item.item_id}" target="_blank">${escapeHtml(item.item_name || `Item ${item.item_id}`)}</a>`;
                    html += `<div style="padding: 5px; background: #f0f0f0; border-radius: 3px;"><strong>${slotName}:</strong> ${itemLink}</div>`;
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            modalContent.innerHTML = html;
            modal.style.display = 'block';
        }

        loadData();
    </script>
</body>
</html>
