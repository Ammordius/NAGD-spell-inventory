<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAKP Class Rankings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header a {
            color: white;
            text-decoration: underline;
            font-size: 0.9em;
            margin-top: 10px;
            display: inline-block;
        }

        header a:hover {
            color: #f0f0f0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
        }

        .score-breakdown {
            margin-top: 20px;
        }

        .score-breakdown h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .score-breakdown table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .score-breakdown th,
        .score-breakdown td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .score-breakdown th {
            background-color: #667eea;
            color: white;
        }

        .score-breakdown tr:hover {
            background-color: #f5f5f5;
        }

        .clickable-row {
            cursor: pointer;
        }

        .clickable-row:hover {
            background-color: #f0f0f0;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #495057;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }

        .table-container {
            overflow-x: auto;
            max-height: 75vh;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;  /* Allow columns to resize when others are hidden */
        }

        thead {
            position: sticky;
            top: 0;
            background: #667eea;
            color: white;
            z-index: 10;
        }

        th {
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
        }

        tbody tr {
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
        }

        tbody tr:hover {
            background-color: #f8f9fa;
        }

        td {
            padding: 12px 10px;
            font-size: 13px;
        }

        .rank {
            font-weight: 700;
            color: #667eea;
            text-align: center;
        }

        .name {
            font-weight: 600;
        }

        .name a {
            color: #667eea;
            text-decoration: none;
        }

        .name a:hover {
            text-decoration: underline;
        }

        .score {
            text-align: right;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .score.high {
            color: #28a745;
        }

        .score.medium {
            color: #ffc107;
        }

        .score.low {
            color: #dc3545;
        }

        .focus-badge {
            display: inline-block;
            background: #e7f3ff;
            color: #667eea;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            margin: 2px;
        }

        .loading, .error {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-size: 18px;
        }

        .error {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>TAKP Class Rankings</h1>
            <p>Level 65 Character Rankings with Focus Analysis</p>
            <a href="scoring_explanation.html">How are scores calculated?</a>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Filter Class:</label>
                <select id="filterClass">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div class="control-group">
                <label>Sort by:</label>
                <select id="sortBy">
                    <option value="overall">Overall Score</option>
                    <option value="class_rank">Class Rank</option>
                    <option value="hp">HP %</option>
                    <option value="mana">Mana %</option>
                    <option value="ac">AC %</option>
                    <option value="atk">ATK %</option>
                    <option value="focus">Focus Score</option>
                </select>
            </div>
            <div class="control-group">
                <button id="toggleWeights" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Customize Weights
                </button>
            </div>
        </div>

        <div id="weightPanel" style="display: none; background: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 8px; border: 1px solid #dee2e6;">
            <h3 style="margin-top: 0;">Custom Weight Adjustment</h3>
            <p style="color: #6c757d; font-size: 0.9em;">Adjust stat and focus weights to customize rankings. Changes are saved locally and apply to the selected class.</p>
            <div style="margin-bottom: 15px;">
                <label><strong>Class:</strong></label>
                <select id="weightClass" style="margin-left: 10px; padding: 5px;">
                    <option value="">All Classes</option>
                </select>
            </div>
            <div id="weightSliders" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <!-- Sliders will be generated here -->
            </div>
            <div id="focusWeightSliders" style="margin-top: 20px; display: none;">
                <!-- Focus weight sliders will be generated here -->
            </div>
            <div style="margin-top: 20px;">
                <label style="display: flex; align-items: center; margin-bottom: 15px;">
                    <input type="checkbox" id="advancedResists" checked style="margin-right: 8px; width: 18px; height: 18px;">
                    <strong>Advanced Resists</strong>
                    <span style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">
                        (Individual resist scoring: Full weight up to 220, linear decrease to 0.35 at 320, 0.35 from 320-500, 0 above 500)
                    </span>
                </label>
            </div>
            <div style="margin-top: 20px;">
                <button id="resetWeights" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                    Reset to Default
                </button>
                <button id="applyWeights" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Apply Weights
                </button>
            </div>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">Loading rankings data...</div>
            <div id="error" class="error" style="display: none;"></div>
            <table id="rankingsTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Class Rank</th>
                        <th>Name</th>
                        <th>Guild</th>
                        <th>Class</th>
                        <th>Overall</th>
                        <th class="stat-col" data-stat="hp">HP</th>
                        <th class="stat-col" data-stat="mana">Mana</th>
                        <th class="stat-col" data-stat="ac">AC</th>
                        <th class="stat-col" data-stat="atk">ATK</th>
                        <th class="stat-col" data-stat="resists">Resists</th>
                        <th>Focus %</th>
                        <th class="stat-col" data-stat="spelldmg">Spell Dmg %</th>
                        <th>Damage Types</th>
                        <th>Other Focii</th>
                    </tr>
                </thead>
                <tbody id="rankingsBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Score Breakdown Modal -->
    <div id="scoreModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        let characters = [];
        let filteredCharacters = [];
        let filterClass = '';
        let sortBy = 'overall';

        let classWeights = {};
        let customWeights = {}; // User-customized weights
        let originalClassWeights = {}; // Backup of original weights

        // Weight customization functions
        function loadCustomWeights() {
            const saved = localStorage.getItem('customWeights');
            if (saved) {
                try {
                    customWeights = JSON.parse(saved);
                    // Apply custom weights
                    applyCustomWeights();
                } catch (e) {
                    console.error('Error loading custom weights:', e);
                }
            }
        }

        function saveCustomWeights() {
            localStorage.setItem('customWeights', JSON.stringify(customWeights));
        }

        function applyCustomWeights() {
            // Merge custom weights into classWeights
            for (const [className, customWeight] of Object.entries(customWeights)) {
                if (classWeights[className]) {
                    Object.assign(classWeights[className], customWeight);
                }
            }
        }

        function setupWeightControls() {
            // Populate class selector for weights
            const weightClassSelect = document.getElementById('weightClass');
            if (!weightClassSelect) return; // Panel might not exist yet
            
            const classes = new Set(characters.map(c => c.class).filter(c => c));
            [...classes].sort().forEach(cls => {
                const option = document.createElement('option');
                option.value = cls;
                option.textContent = cls;
                weightClassSelect.appendChild(option);
            });

            // Toggle weight panel
            const toggleBtn = document.getElementById('toggleWeights');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    const panel = document.getElementById('weightPanel');
                    if (panel) {
                        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                        if (panel.style.display === 'block') {
                            // Default to currently filtered class when opening Customize Weights
                            const weightClassSelect = document.getElementById('weightClass');
                            if (weightClassSelect && filterClass && weightClassSelect.querySelector(`option[value="${filterClass}"]`)) {
                                weightClassSelect.value = filterClass;
                            }
                            updateWeightSliders();
                        }
                    }
                });
            }

            // Class selector change
            weightClassSelect.addEventListener('change', () => {
                updateWeightSliders();
            });

            // Advanced resists checkbox
            const advancedResistsCheckbox = document.getElementById('advancedResists');
            if (advancedResistsCheckbox) {
                // Load saved preference
                const savedAdvancedResists = localStorage.getItem('advancedResists');
                if (savedAdvancedResists !== null) {
                    advancedResists = savedAdvancedResists === 'true';
                    advancedResistsCheckbox.checked = advancedResists;
                }
                
                advancedResistsCheckbox.addEventListener('change', () => {
                    advancedResists = advancedResistsCheckbox.checked;
                    localStorage.setItem('advancedResists', advancedResists.toString());
                });
            }

            // Apply weights button
            const applyBtn = document.getElementById('applyWeights');
            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    saveWeightValues();
                    applyCustomWeights();
                    recalculateScores();
                    filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                });
            }

            // Reset weights button
            const resetBtn = document.getElementById('resetWeights');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    const selectedClass = document.getElementById('weightClass').value;
                    if (selectedClass && customWeights[selectedClass]) {
                        delete customWeights[selectedClass];
                        saveCustomWeights();
                        // Restore original weights
                        if (originalClassWeights[selectedClass]) {
                            classWeights[selectedClass] = JSON.parse(JSON.stringify(originalClassWeights[selectedClass]));
                        }
                        updateWeightSliders();
                        recalculateScores();
                        filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                    } else if (!selectedClass) {
                        // Reset all
                        customWeights = {};
                        saveCustomWeights();
                        classWeights = JSON.parse(JSON.stringify(originalClassWeights));
                        updateWeightSliders();
                        recalculateScores();
                        filterAndSort(); // Re-apply filter and sort after recalculating (calls renderTable internally)
                    }
                });
            }
        }

        function updateWeightSliders() {
            const selectedClass = document.getElementById('weightClass')?.value;
            const slidersDiv = document.getElementById('weightSliders');
            if (!slidersDiv) return;
            
            slidersDiv.innerHTML = '';

            if (!selectedClass) {
                slidersDiv.innerHTML = '<p style="color: #6c757d;">Select a class to customize weights</p>';
                return;
            }

            const weights = classWeights[selectedClass] || {};
            
            // Ensure all stat keys exist in weights (even if 0) so users can adjust them
            // This allows users to enable stats that are 0 by default
            const allStatKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
            allStatKeys.forEach(key => {
                if (weights[key] === undefined) {
                    // Set to 0 if not defined, so slider can be shown and adjusted
                    weights[key] = 0.0;
                }
            });
            
            // Calculate normalized weights to show current contributions
            const normalized = normalizeWeights(weights);
            
            // All stats are always shown, even if default is 0
            // This allows users to enable stats that are 0 by default (e.g., AC for casters, Mana for melees)
            const statKeys = [
                { key: 'hp_pct', label: 'HP', default: 1.0 },
                { key: 'mana_pct', label: 'Mana', default: 0.0 },  // Can be enabled even if class doesn't have mana
                { key: 'ac_pct', label: 'AC', default: 0.0 },  // Can be enabled even if class doesn't have AC
                { key: 'resists_pct', label: 'Resists', default: 1.0 }
            ];

            statKeys.forEach(stat => {
                // Use the actual weight value, even if it's 0 (so AC can be adjusted for casters)
                const rawValue = weights[stat.key] !== undefined ? weights[stat.key] : stat.default;
                const normalizedValue = normalized[stat.key] || 0;
                const sliderDiv = document.createElement('div');
                sliderDiv.style.padding = '10px';
                sliderDiv.style.background = 'white';
                sliderDiv.style.borderRadius = '4px';
                sliderDiv.innerHTML = `
                    <label style="display: block; margin-bottom: 5px;">
                        <strong>${stat.label}:</strong> 
                        <span id="value_${stat.key}">${rawValue.toFixed(2)}</span>
                        <span id="contrib_${stat.key}" style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">
                            (${(normalizedValue * 100).toFixed(1)}% contribution)
                        </span>
                    </label>
                    <input type="range" 
                           id="slider_${stat.key}" 
                           min="0" 
                           max="3" 
                           step="0.1" 
                           value="${rawValue}" 
                           style="width: 100%;"
                           oninput="updateSliderValue('${stat.key}', this.value)">
                    ${normalizedValue === 0 && rawValue === 0 ? '<p style="font-size: 0.85em; color: #6c757d; margin: 5px 0 0 0; font-style: italic;">Increase this value to enable this stat in scoring</p>' : ''}
                `;
                slidersDiv.appendChild(sliderDiv);
            });

            // Focus weight multiplier (2.4x HP weight)
            const hpWeight = weights.hp_pct || 1.0;
            const focusMultiplier = customWeights[selectedClass]?._meta?.focusMultiplier || 2.4;
            // Calculate focus contribution percentage
            const focusContrib = (normalized.focusTarget || 0) * 100;
            const sliderDiv = document.createElement('div');
            sliderDiv.style.padding = '10px';
            sliderDiv.style.background = 'white';
            sliderDiv.style.borderRadius = '4px';
            sliderDiv.innerHTML = `
                <label style="display: block; margin-bottom: 5px;">
                    <strong>Focus Weight Multiplier:</strong> 
                    <span id="value_focus_mult">${focusMultiplier.toFixed(1)}</span>
                    <span style="color: #6c757d; font-size: 0.9em; margin-left: 8px;">
                        (${focusContrib.toFixed(1)}% contribution)
                    </span>
                </label>
                <input type="range" 
                       id="slider_focus_mult" 
                       min="0" 
                       max="5" 
                       step="0.1" 
                       value="${focusMultiplier}" 
                       style="width: 100%;"
                       oninput="updateFocusMultiplierValue(this.value)">
                <p style="font-size: 0.85em; color: #6c757d; margin: 5px 0 0 0;">
                    Total focus weight = (HP weight Ã— multiplier). Default: 2.4
                </p>
            `;
            slidersDiv.appendChild(sliderDiv);
            
            // Add focus weight customization section
            const focusSlidersDiv = document.getElementById('focusWeightSliders');
            if (focusSlidersDiv) {
                focusSlidersDiv.innerHTML = '';
                focusSlidersDiv.style.display = 'block';
                
                const focusWeights = weights.focus || {};
                const customFocusWeights = customWeights[selectedClass]?.focus || {};
                
                if (Object.keys(focusWeights).length === 0) {
                    focusSlidersDiv.innerHTML = '<p style="color: #6c757d; padding: 10px;">This class has no focus weights configured.</p>';
                } else {
                    const headerDiv = document.createElement('div');
                    headerDiv.style.marginBottom = '15px';
                    headerDiv.style.padding = '10px';
                    headerDiv.style.background = '#e7f3ff';
                    headerDiv.style.borderRadius = '4px';
                    headerDiv.innerHTML = `
                        <h4 style="margin: 0;">Focus Weights</h4>
                        <p style="margin: 5px 0 0 0; font-size: 0.9em; color: #6c757d;">
                            Adjust individual focus category weights. These are relative weights that will be scaled by the Focus Weight Multiplier.
                        </p>
                    `;
                    focusSlidersDiv.appendChild(headerDiv);
                    
                    const focusGrid = document.createElement('div');
                    focusGrid.style.display = 'grid';
                    focusGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
                    focusGrid.style.gap = '15px';
                    focusGrid.style.marginTop = '15px';
                    
                    // Sort focus categories for consistent display; include keys from custom so 0-weight can be adjusted
                    const focusKeys = [...new Set([...Object.keys(focusWeights || {}), ...Object.keys(customFocusWeights || {})])].sort();
                    
                    focusKeys.forEach(focusKey => {
                        const focusValue = customFocusWeights[focusKey] !== undefined ? customFocusWeights[focusKey] : (focusWeights[focusKey] !== undefined ? focusWeights[focusKey] : 0);
                        
                        if (typeof focusValue === 'object' && focusValue !== null) {
                            // Nested object (e.g., Spell Damage with damage types)
                            const nestedDiv = document.createElement('div');
                            nestedDiv.style.padding = '10px';
                            nestedDiv.style.background = 'white';
                            nestedDiv.style.borderRadius = '4px';
                            nestedDiv.style.border = '1px solid #dee2e6';
                            
                            let nestedHtml = `<div style="margin-bottom: 10px;"><strong>${focusKey}:</strong></div>`;
                            
                            const nestedKeys = Object.keys(focusValue).sort();
                            nestedKeys.forEach(nestedKey => {
                                const currentValue = customFocusWeights[focusKey]?.[nestedKey] !== undefined 
                                    ? customFocusWeights[focusKey][nestedKey] 
                                    : focusValue[nestedKey];
                                const sliderId = `slider_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                const valueId = `value_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                                
                                nestedHtml += `
                                    <div style="margin-bottom: 10px;">
                                        <label style="display: block; margin-bottom: 5px;">
                                            <strong>${nestedKey}:</strong> 
                                            <span id="${valueId}">${currentValue.toFixed(2)}</span>
                                        </label>
                                        <input type="range" 
                                               id="${sliderId}" 
                                               min="0" 
                                               max="3" 
                                               step="0.1" 
                                               value="${currentValue}" 
                                               style="width: 100%;"
                                               oninput="document.getElementById('${valueId}').textContent = parseFloat(this.value).toFixed(2)">
                                    </div>
                                `;
                            });
                            
                            nestedDiv.innerHTML = nestedHtml;
                            focusGrid.appendChild(nestedDiv);
                        } else {
                            // Simple numeric value
                            const currentValue = customFocusWeights[focusKey] !== undefined ? customFocusWeights[focusKey] : focusValue;
                            const sliderId = `slider_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                            const valueId = `value_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                            
                            const sliderDiv = document.createElement('div');
                            sliderDiv.style.padding = '10px';
                            sliderDiv.style.background = 'white';
                            sliderDiv.style.borderRadius = '4px';
                            sliderDiv.innerHTML = `
                                <label style="display: block; margin-bottom: 5px;">
                                    <strong>${focusKey}:</strong> 
                                    <span id="${valueId}">${currentValue.toFixed(2)}</span>
                                </label>
                                <input type="range" 
                                       id="${sliderId}" 
                                       min="0" 
                                       max="3" 
                                       step="0.1" 
                                       value="${currentValue}" 
                                       style="width: 100%;"
                                       oninput="document.getElementById('${valueId}').textContent = parseFloat(this.value).toFixed(2)">
                            `;
                            focusGrid.appendChild(sliderDiv);
                        }
                    });
                    
                    focusSlidersDiv.appendChild(focusGrid);
                }
            }
        }

        function updateSliderValue(statKey, value) {
            const val = parseFloat(value);
            document.getElementById(`value_${statKey}`).textContent = val.toFixed(2);
            
            // Update contribution percentage for this stat and all others (including focus)
            const selectedClass = document.getElementById('weightClass')?.value;
            if (selectedClass) {
                const weights = {...classWeights[selectedClass]};
                // Ensure the stat key exists (even if it was 0 or undefined)
                weights[statKey] = val;
                // Ensure all stat keys exist for normalization
                ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'].forEach(key => {
                    if (weights[key] === undefined) {
                        weights[key] = 0.0;
                    }
                });
                const normalized = normalizeWeights(weights);
                
                // Update this stat's contribution
                const contrib = (normalized[statKey] || 0) * 100;
                const contribSpan = document.getElementById(`contrib_${statKey}`);
                if (contribSpan) {
                    contribSpan.textContent = ` (${contrib.toFixed(1)}% contribution)`;
                }
                
                // Update all other stat contributions
                ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'].forEach(key => {
                    if (key !== statKey) {
                        const otherContrib = (normalized[key] || 0) * 100;
                        const otherContribSpan = document.getElementById(`contrib_${key}`);
                        if (otherContribSpan) {
                            otherContribSpan.textContent = ` (${otherContrib.toFixed(1)}% contribution)`;
                        }
                    }
                });
                
                // Update focus multiplier contribution
                const focusContrib = (normalized.focusTarget || 0) * 100;
                const focusMultValueSpan = document.getElementById('value_focus_mult');
                if (focusMultValueSpan) {
                    const focusMultContribSpan = focusMultValueSpan.nextElementSibling;
                    if (focusMultContribSpan && focusMultContribSpan.tagName === 'SPAN') {
                        focusMultContribSpan.textContent = ` (${focusContrib.toFixed(1)}% contribution)`;
                    }
                }
            }
        }

        function updateFocusMultiplierValue(value) {
            const val = parseFloat(value);
            document.getElementById('value_focus_mult').textContent = val.toFixed(1);
            
            // Update focus contribution percentage
            const selectedClass = document.getElementById('weightClass')?.value;
            if (selectedClass) {
                const weights = {...classWeights[selectedClass]};
                const normalized = normalizeWeights(weights);
                const focusContrib = (normalized.focusTarget || 0) * 100;
                const focusMultValueSpan = document.getElementById('value_focus_mult');
                if (focusMultValueSpan) {
                    const focusMultContribSpan = focusMultValueSpan.nextElementSibling;
                    if (focusMultContribSpan && focusMultContribSpan.tagName === 'SPAN') {
                        focusMultContribSpan.textContent = ` (${focusContrib.toFixed(1)}% contribution)`;
                    }
                }
            }
        }

        function saveWeightValues() {
            const selectedClass = document.getElementById('weightClass')?.value;
            if (!selectedClass) return;

            if (!customWeights[selectedClass]) {
                customWeights[selectedClass] = {};
            }

            // ATK and Haste are now in focus weights, not stat weights
            const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
            statKeys.forEach(key => {
                const slider = document.getElementById(`slider_${key}`);
                if (slider) {
                    customWeights[selectedClass][key] = parseFloat(slider.value);
                }
            });

            // Store focus multiplier separately
            const focusMultSlider = document.getElementById('slider_focus_mult');
            if (focusMultSlider) {
                if (!customWeights[selectedClass]._meta) {
                    customWeights[selectedClass]._meta = {};
                }
                customWeights[selectedClass]._meta.focusMultiplier = parseFloat(focusMultSlider.value);
            }
            
            // Save focus weights (use union of class + custom keys so 0-weight and custom keys are saved)
            const focusWeights = classWeights[selectedClass]?.focus || {};
            const customFocus = customWeights[selectedClass]?.focus || {};
            const allFocusKeys = [...new Set([...Object.keys(focusWeights), ...Object.keys(customFocus)])];
            if (!customWeights[selectedClass].focus) {
                customWeights[selectedClass].focus = {};
            }
            
            allFocusKeys.forEach(focusKey => {
                const focusValue = focusWeights[focusKey] ?? customFocus[focusKey];
                
                if (typeof focusValue === 'object' && focusValue !== null) {
                    // Nested object (e.g., Spell Damage with damage types)
                    if (!customWeights[selectedClass].focus[focusKey]) {
                        customWeights[selectedClass].focus[focusKey] = {};
                    }
                    const nestedKeys = [...new Set([...Object.keys(focusValue || {}), ...Object.keys(customWeights[selectedClass].focus[focusKey] || {})])];
                    nestedKeys.forEach(nestedKey => {
                        const sliderId = `slider_focus_${focusKey}_${nestedKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                        const slider = document.getElementById(sliderId);
                        if (slider) {
                            customWeights[selectedClass].focus[focusKey][nestedKey] = parseFloat(slider.value);
                        }
                    });
                } else {
                    // Simple numeric value (including 0 so user can adjust up from zero)
                    const sliderId = `slider_focus_${focusKey}`.replace(/[^a-zA-Z0-9_]/g, '_');
                    const slider = document.getElementById(sliderId);
                    if (slider) {
                        customWeights[selectedClass].focus[focusKey] = parseFloat(slider.value);
                    }
                }
            });

            saveCustomWeights();
        }

        function calculateResistScore(resistValue) {
            /**
             * Calculate resist score with progressive taper curve:
             * - L = 220 (start taper)
             * - H = 500 (hard-cap point)
             * - r = 0.35 (post-cap marginal credit)
             * - p = 1.2 (controls how "progressive" the taper is)
             * - t = (x - L) / (H - L) = (x - 220) / 280
             * 
             * S(x) = {
             *     x,                                    if x <= 220
             *     220 + (x - 220)(r + (1 - r)(1 - t)^p), if 220 < x < 500
             *     318 + r(x - 500),                      if x >= 500
             * }
             * 
             * Score percentage = (S(x) / S(500)) * 100, where S(500) = 318
             */
            if (resistValue <= 0) {
                return { score: 0.0, weight: 1.0 };
            }
            
            const L = 220.0;  // Start taper
            const H = 500.0;   // Hard-cap point
            const r = 0.35;    // Post-cap marginal credit
            const p = 1.2;     // Progressive taper control
            
            const x = parseFloat(resistValue);
            let S_x;
            
            if (x <= L) {
                // No taper: S(x) = x
                S_x = x;
            } else if (x < H) {
                // Progressive taper: S(x) = 220 + (x - 220)(r + (1 - r)(1 - t)^p)
                const t = (x - L) / (H - L);  // t = (x - 220) / 280
                S_x = L + (x - L) * (r + (1 - r) * Math.pow(1 - t, p));
            } else {
                // Post-cap: S(x) = 318 + r(x - 500)
                const S_500 = L + r * (H - L);  // = 220 + 0.35 * 280 = 318
                S_x = S_500 + r * (x - H);
            }
            
            // Normalize: S(500) = 318, so score percentage = (S(x) / 318) * 100
            // But cap at 100% to match HP/AC normalization
            const S_500 = L + r * (H - L);  // = 318
            const score = (S_500 > 0) ? Math.min((S_x / S_500) * 100.0, 100.0) : 0.0;
            
            // Weight is always 1.0
            const weight = 1.0;
            
            return { score: score, weight: weight };
        }

        function normalizeWeights(weights, focusMultiplier = 2.4) {
            // Target percentages: 20% HP, 17.5% AC, 17.5% Resists (TOTAL across 5 resists), 30% Focus, 15% Mana
            const TARGET_HP = 0.20;
            const TARGET_AC = 0.175;
            const TARGET_RESISTS = 0.175;  // TOTAL across all 5 resists
            const TARGET_FOCUS = 0.30;  // Includes ATK, FT, Haste, and spell focuses
            const TARGET_MANA = 0.15;
            
            // Check which stats are applicable
            // hasMana: class has mana (mana_pct > 0) - used for FT weight
            const hasMana = (weights.mana_pct || 0) > 0;
            const hasAc = weights.ac_pct !== undefined;
            
            // Calculate total target percentage
            // Always include all targets, but normalize based on what's actually set
            let totalTarget = TARGET_HP + TARGET_RESISTS + TARGET_FOCUS;
            if (hasMana) totalTarget += TARGET_MANA;
            if (hasAc) totalTarget += TARGET_AC;
            
            // Normalize targets to sum to 1.0
            const hpTarget = TARGET_HP / totalTarget;
            const resistsTarget = TARGET_RESISTS / totalTarget;
            const focusTarget = TARGET_FOCUS / totalTarget;
            const manaTarget = hasMana ? (TARGET_MANA / totalTarget) : 0.0;
            const acTarget = hasAc ? (TARGET_AC / totalTarget) : 0.0;
            
            // Store focusTarget in the normalized object for display
            const normalized = {
                hp_pct: hpTarget,
                resists_pct: resistsTarget,
                mana_pct: manaTarget,
                ac_pct: acTarget,
                focusTarget: focusTarget  // Store for display
            };
            
            // Calculate focus weight components
            // ATK and Haste are now in focus dict, not stat weights
            let atkWeightRaw = 0.0;  // Will be extracted from focus dict below
            let hasteWeightRaw = 0.0;  // Will be extracted from focus dict below
            // FT (Flowing Thought, cap 15) - decent weight for mana classes when capped
            const ftWeightRaw = hasMana ? 4.0 : 0.0;
            
            const focusWeights = weights.focus || {};
            let totalSpellFocusWeight = 0.0;
            for (const [focusCat, focusValue] of Object.entries(focusWeights)) {
                if (focusCat === 'ATK') {
                    // Extract ATK weight from focus dict
                    atkWeightRaw = (typeof focusValue === 'number') ? focusValue : 0.0;
                } else if (focusCat === 'Haste') {
                    // Extract Haste weight from focus dict (for Warriors, etc.)
                    hasteWeightRaw = (typeof focusValue === 'number') ? focusValue : 0.0;
                } else if (typeof focusValue === 'object') {
                    totalSpellFocusWeight += Object.values(focusValue).reduce((a, b) => a + b, 0);
                } else {
                    // Include all other focus items (Darkblade, Raex Chest, Shield of Strife, etc.)
                    totalSpellFocusWeight += focusValue;
                }
            }
            
            // If Haste is still in haste_pct (backward compatibility), use that
            if (hasteWeightRaw === 0.0) {
                hasteWeightRaw = weights.haste_pct || 0.0;
            }
            
            // Total focus components = ATK + Haste + FT + spell focuses + special items
            const totalFocusComponents = atkWeightRaw + hasteWeightRaw + ftWeightRaw + totalSpellFocusWeight;
            
            // Scale focus components to achieve target focus percentage
            const focusScale = (totalFocusComponents > 0) ? (focusTarget / totalFocusComponents) : 0.0;
            
            // Add remaining normalized weights (focusTarget already set above)
            normalized.atk_pct = 0.0;  // Moved to focus
            normalized.haste_pct = 0.0;  // Moved to focus
            normalized.ft_weight = ftWeightRaw * focusScale;
            normalized.focus = {};
            
            // Normalize focus weights (with scaling applied)
            if (focusWeights && focusScale > 0) {
                for (const [focusCat, focusValue] of Object.entries(focusWeights)) {
                    if (typeof focusValue === 'object' && focusValue !== null) {
                        normalized.focus[focusCat] = {};
                        for (const [k, v] of Object.entries(focusValue)) {
                            if (typeof v === 'number') {
                                normalized.focus[focusCat][k] = v * focusScale;
                            }
                        }
                    } else if (typeof focusValue === 'number') {
                        normalized.focus[focusCat] = focusValue * focusScale;
                    }
                }
            }
            
            // Store ATK and Haste as focus components (if not already in normalized focus dict)
            if (atkWeightRaw > 0 && !normalized.focus['ATK']) {
                normalized.focus['ATK'] = atkWeightRaw * focusScale;
            }
            if (hasteWeightRaw > 0 && !normalized.focus['Haste']) {
                normalized.focus['Haste'] = hasteWeightRaw * focusScale;
            }
            
            // Ensure Darkblade and Raex Chest are normalized if they exist in raw weights
            // (They might be in the raw weights but not in focusWeights if the JSON format is old)
            const rawFocusWeights = weights.focus || {};
            if (rawFocusWeights['Darkblade'] !== undefined && !normalized.focus['Darkblade']) {
                const darkbladeWeight = typeof rawFocusWeights['Darkblade'] === 'number' ? rawFocusWeights['Darkblade'] : 1.0;
                normalized.focus['Darkblade'] = darkbladeWeight * focusScale;
            }
            if (rawFocusWeights['Raex Chest'] !== undefined && !normalized.focus['Raex Chest']) {
                const raexWeight = typeof rawFocusWeights['Raex Chest'] === 'number' ? rawFocusWeights['Raex Chest'] : 1.0;
                normalized.focus['Raex Chest'] = raexWeight * focusScale;
            }
            
            return normalized;
        }

        function recalculateScores() {
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass || !classWeights[charClass]) return;

                const customWeight = customWeights[charClass] || {};
                const focusMultiplier = customWeight._meta?.focusMultiplier || 2.4;
                
                let weights = JSON.parse(JSON.stringify(originalClassWeights[charClass] || classWeights[charClass]));
                
                Object.keys(customWeight).forEach(key => {
                    if (key !== '_meta' && key !== 'focus' && weights.hasOwnProperty(key)) {
                        weights[key] = customWeight[key];
                    }
                });
                
                // Apply custom focus weights
                if (customWeight.focus && weights.focus) {
                    Object.keys(customWeight.focus).forEach(focusKey => {
                        if (weights.focus[focusKey] !== undefined) {
                            if (typeof customWeight.focus[focusKey] === 'object' && customWeight.focus[focusKey] !== null) {
                                // Nested object
                                if (!weights.focus[focusKey]) {
                                    weights.focus[focusKey] = {};
                                }
                                Object.keys(customWeight.focus[focusKey]).forEach(nestedKey => {
                                    if (weights.focus[focusKey][nestedKey] !== undefined) {
                                        weights.focus[focusKey][nestedKey] = customWeight.focus[focusKey][nestedKey];
                                    }
                                });
                            } else {
                                // Simple value
                                weights.focus[focusKey] = customWeight.focus[focusKey];
                            }
                        }
                    });
                }

                const normalized = normalizeWeights(weights, focusMultiplier);
                const scores = char.scores || {};
                let totalScore = 0.0;
                let totalWeight = 0.0;

                if (scores.hp_pct !== undefined && normalized.hp_pct > 0) {
                    totalScore += scores.hp_pct * normalized.hp_pct;
                    totalWeight += normalized.hp_pct;
                }
                if (scores.mana_pct !== undefined && normalized.mana_pct > 0) {
                    totalScore += scores.mana_pct * normalized.mana_pct;
                    totalWeight += normalized.mana_pct;
                }
                if (scores.ac_pct !== undefined && normalized.ac_pct > 0) {
                    totalScore += scores.ac_pct * normalized.ac_pct;
                    totalWeight += normalized.ac_pct;
                }
                // ATK, FT, and Haste are now part of focus weight (handled below)
                
                // Resists - use advanced resists if enabled
                if (scores.resists_pct !== undefined && normalized.resists_pct > 0) {
                    if (advancedResists && char.individual_resists) {
                        // Calculate individual resist scores with weight curve
                        // Resists weight is TOTAL across all 5 resists, so divide by number of resists
                        const resistTypes = ['MR', 'FR', 'CR', 'DR', 'PR'];
                        const numResists = resistTypes.filter(rt => char.individual_resists[rt] !== undefined && char.individual_resists[rt] > 0).length || 5;
                        const resistWeightPerResist = normalized.resists_pct / numResists;
                        
                        let totalResistScore = 0.0;
                        let totalResistWeight = 0.0;
                        
                        resistTypes.forEach(resistType => {
                            const resistValue = char.individual_resists[resistType] || 0;
                            if (resistValue > 0) {
                                const { score, weight: curveWeight } = calculateResistScore(resistValue);
                                // The effective weight per resist is resists_pct / num_resists
                                const effectiveWeight = resistWeightPerResist * curveWeight;
                                totalResistScore += score * effectiveWeight;
                                totalResistWeight += effectiveWeight;
                            }
                        });
                        
                        if (totalResistWeight > 0) {
                            // Average the weighted scores
                            const avgResistScore = totalResistScore / totalResistWeight;
                            // Total resists weight should equal normalized.resists_pct (17.5% total)
                            totalScore += avgResistScore * normalized.resists_pct;
                            totalWeight += normalized.resists_pct;
                        }
                    } else {
                        // Use simple total resists percentage
                        totalScore += scores.resists_pct * normalized.resists_pct;
                        totalWeight += normalized.resists_pct;
                    }
                }
                
                // Focus weights - includes ATK, FT, Haste, and spell focuses
                const focusWeights = normalized.focus || {};
                
                // Add ATK to focus if applicable
                if (scores.atk_pct !== undefined) {
                    const atkWeight = focusWeights['ATK'] || 0.0;
                    if (atkWeight > 0) {
                        totalScore += scores.atk_pct * atkWeight;
                        totalWeight += atkWeight;
                    }
                }
                
                // Add Haste to focus if applicable
                if (scores.haste_pct !== undefined) {
                    const hasteWeight = focusWeights['Haste'] || 0.0;
                    if (hasteWeight > 0) {
                        totalScore += scores.haste_pct * hasteWeight;
                        totalWeight += hasteWeight;
                    }
                }
                
                // Add FT (partial when uncapped, full when 15/15)
                const ftWeight = normalized.ft_weight || 0.0;
                if (ftWeight > 0 && (scores.ft_capped !== undefined || scores.ft_current !== undefined)) {
                    const ftPct = scores.ft_capped ? 100 : (scores.ft_pct != null ? scores.ft_pct : 0);
                    totalScore += (ftPct / 100.0) * ftWeight;
                    totalWeight += ftWeight;
                }
                
                // Spell focuses and special focus items
                const focusScores = scores.focus_scores || {};
                if (charClass === 'Warrior') {
                    // Handle Warrior focuses individually: Darkblade, Raex Chest, Haste (each weight 1.0)
                    for (const [focusCat, weight] of Object.entries(focusWeights)) {
                        if (focusCat === 'ATK') continue;  // Already handled above
                        if (['Darkblade', 'Raex Chest', 'Haste'].includes(focusCat)) {
                            const focusScore = focusScores[focusCat] || 0;
                            if (typeof weight === 'number' && weight > 0) {
                                totalScore += focusScore * weight;
                                totalWeight += weight;
                            }
                        }
                    }
                } else if (Object.keys(focusWeights).length > 0 && scores.focus_overall_pct !== undefined) {
                    // For other classes, use focus_overall_pct
                    let totalFocusWeight = 0.0;
                    for (const [focusCat, weight] of Object.entries(focusWeights)) {
                        // Skip ATK and Haste - already handled above
                        if (focusCat === 'ATK' || focusCat === 'Haste') continue;
                        if (typeof weight === 'object') {
                            totalFocusWeight += Object.values(weight).reduce((a, b) => a + b, 0);
                        } else {
                            totalFocusWeight += weight;
                        }
                    }
                    if (totalFocusWeight > 0) {
                        totalScore += scores.focus_overall_pct * totalFocusWeight;
                        totalWeight += totalFocusWeight;
                    }
                }

                // Store total points (not normalized percentage)
                char.total_points = totalScore;
                char.total_weight = totalWeight;
                
                // Calculate weighted average percentage (for display)
                char.overall_score_pct = totalWeight > 0 ? (totalScore / totalWeight) : 0;
            });

            // Find maximum total points per class for normalization
            // Do this AFTER all characters have been processed
            const maxPointsByClass = {};
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass) return;
                const totalPts = char.total_points || 0;
                if (totalPts > 0 && (!maxPointsByClass[charClass] || totalPts > maxPointsByClass[charClass])) {
                    maxPointsByClass[charClass] = totalPts;
                }
            });
            
            // Normalize overall_score by class maximum (as percentage of max points)
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass || !maxPointsByClass[charClass] || maxPointsByClass[charClass] === 0) {
                    char.overall_score = 0;
                } else {
                    // overall_score is now percentage of max points for this class
                    const totalPts = char.total_points || 0;
                    char.overall_score = (totalPts / maxPointsByClass[charClass]) * 100.0;
                }
            });
            
            // Debug: Log max points for Paladins
            if (maxPointsByClass['Paladin']) {
                console.log(`Paladin max total_points: ${maxPointsByClass['Paladin'].toFixed(2)}`);
                const paladins = characters.filter(c => c.class === 'Paladin').sort((a, b) => (b.total_points || 0) - (a.total_points || 0)).slice(0, 5);
                paladins.forEach(p => {
                    console.log(`  ${p.name}: ${(p.total_points || 0).toFixed(2)} points = ${(p.overall_score || 0).toFixed(2)}%`);
                });
            }

            // Sort by overall score for overall ranking (descending)
            characters.sort((a, b) => {
                const scoreA = a.overall_score || 0;
                const scoreB = b.overall_score || 0;
                // Use a small epsilon for floating point comparison
                if (Math.abs(scoreB - scoreA) < 0.001) {
                    // If scores are essentially equal, maintain original order or sort by name
                    return (a.name || '').localeCompare(b.name || '');
                }
                return scoreB - scoreA;
            });
            
            // Calculate overall ranks - each character gets a unique rank based on position
            characters.forEach((char, index) => {
                char.overall_rank = index + 1;
            });
            
            // Calculate class ranks separately - group by class, sort each group, then assign ranks
            const charactersByClass = {};
            characters.forEach(char => {
                const charClass = char.class;
                if (!charClass) return;
                if (!charactersByClass[charClass]) {
                    charactersByClass[charClass] = [];
                }
                charactersByClass[charClass].push(char);
            });
            
            // Sort each class by overall_score and assign class ranks
            Object.keys(charactersByClass).forEach(charClass => {
                const classChars = charactersByClass[charClass];
                classChars.sort((a, b) => {
                    const scoreA = a.overall_score || 0;
                    const scoreB = b.overall_score || 0;
                    // Use a small epsilon for floating point comparison
                    if (Math.abs(scoreB - scoreA) < 0.001) {
                        // If scores are essentially equal, maintain original order or sort by name
                        return (a.name || '').localeCompare(b.name || '');
                    }
                    return scoreB - scoreA;
                });
                
                // Each character gets a unique class rank based on position
                classChars.forEach((char, index) => {
                    char.class_rank = index + 1;
                });
            });
        }
        
        async function loadData() {
            try {
                // Try multiple possible paths for GitHub Pages
                const possiblePaths = [
                    'class_rankings.json',  // Same directory
                    './class_rankings.json',  // Explicit same directory
                    '/class_rankings.json',  // Root path
                    window.location.pathname.replace(/\/[^/]*$/, '/') + 'class_rankings.json',  // Same directory as HTML
                ];
                
                // Add repository path if on GitHub Pages
                const repoMatch = window.location.pathname.match(/^\/[^/]+\/[^/]+/);
                if (repoMatch) {
                    possiblePaths.push(repoMatch[0] + '/class_rankings.json');
                }
                
                let jsonPath = '';
                let response = null;
                let lastError = null;
                
                for (const path of possiblePaths) {
                    try {
                        console.log(`Trying to load from: ${path}`);
                        response = await fetch(path);
                        if (response.ok) {
                            jsonPath = path;
                            console.log(`âœ“ Successfully loaded from: ${path}`);
                            break;
                        } else {
                            console.log(`âœ— Failed to load from ${path}: ${response.status}`);
                            lastError = `HTTP ${response.status} from ${path}`;
                        }
                    } catch (e) {
                        console.log(`âœ— Error loading from ${path}:`, e.message);
                        lastError = e.message;
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error(`Could not load class_rankings.json from any path. Last error: ${lastError}. Tried: ${possiblePaths.join(', ')}`);
                }
                
                const data = await response.json();
                console.log('Loaded data, parsing...', Object.keys(data));
                
                // Handle both old format (array) and new format (object with characters)
                if (Array.isArray(data)) {
                    characters = data;
                    console.log(`Loaded ${characters.length} characters (array format)`);
                } else {
                    characters = data.characters || [];
                    classWeights = data.class_weights || {};
                    originalClassWeights = JSON.parse(JSON.stringify(classWeights)); // Deep copy
                    console.log(`Loaded ${characters.length} characters, ${Object.keys(classWeights).length} class weights`);
                }
                filteredCharacters = [...characters];
                
                // Load custom weights from localStorage
                console.log('Loading custom weights...');
                loadCustomWeights();
                
                console.log('Populating filters...');
                populateFilters();
                console.log('Setting up weight controls...');
                setupWeightControls();
                console.log('Rendering table...');
                renderTable();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('rankingsTable').style.display = 'table';
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                console.error('Error:', error);
            }
        }

        function populateFilters() {
            const classes = new Set(characters.map(c => c.class).filter(c => c));
            const classSelect = document.getElementById('filterClass');
            
            [...classes].sort().forEach(cls => {
                const option = document.createElement('option');
                option.value = cls;
                option.textContent = cls;
                classSelect.appendChild(option);
            });
        }

        function filterAndSort() {
            filteredCharacters = characters.filter(char => {
                if (filterClass && char.class !== filterClass) return false;
                return true;
            });
            
            filteredCharacters.sort((a, b) => {
                if (sortBy === 'overall') return b.overall_score - a.overall_score;
                if (sortBy === 'class_rank') {
                    if (a.class !== b.class) return a.class.localeCompare(b.class);
                    return a.class_rank - b.class_rank;
                }
                if (sortBy === 'hp') return (b.stats.hp || 0) - (a.stats.hp || 0);
                if (sortBy === 'mana') return (b.stats.mana || 0) - (a.stats.mana || 0);
                if (sortBy === 'ac') return (b.stats.ac || 0) - (a.stats.ac || 0);
                if (sortBy === 'atk') {
                    const aAtk = parseInt(a.stats.atk_item?.split(' / ')[0] || '0');
                    const bAtk = parseInt(b.stats.atk_item?.split(' / ')[0] || '0');
                    return bAtk - aAtk;
                }
                if (sortBy === 'resists') return (b.scores.resists || 0) - (a.scores.resists || 0);
                if (sortBy === 'focus') return (b.scores.focus_overall_pct || 0) - (a.scores.focus_overall_pct || 0);
                return 0;
            });
            
            renderTable();
        }

        function getScoreClass(score) {
            if (score >= 90) return 'high';
            if (score >= 70) return 'medium';
            return 'low';
        }

        function formatScore(score) {
            if (score === null || score === undefined) return 'N/A';
            if (typeof score !== 'number') return String(score);
            if (isNaN(score)) return 'N/A';
            return score.toFixed(1) + '%';
        }

        function renderTable() {
            const tbody = document.getElementById('rankingsBody');
            tbody.innerHTML = '';
            
            filteredCharacters.forEach((char, index) => {
                const row = document.createElement('tr');
                const scores = char.scores;
                const focii = char.focii || {};
                
                // Get spell damage score (class-specific)
                const spellDmgScore = scores.focus_scores && scores.focus_scores['Spell Damage'] 
                    ? scores.focus_scores['Spell Damage'] 
                    : null;
                
                // Get class-specific weight configuration
                const charClass = char.class || '';
                const classWeightConfig = classWeights[charClass] || {};
                const focusWeights = classWeightConfig.focus || {};
                const spellDamageWeights = focusWeights['Spell Damage'] || {};
                
                // Special handling for Warriors and Pal/SK - show focus items status
                let damageBadges = '';
                let otherBadges = '';
                
                if (charClass === 'Warrior') {
                    // For Warriors, show individual focus items in Damage Types column
                    const focusItems = scores.focus_items || {};
                    const badges = [];
                    if (focusItems.has_darkblade) {
                        badges.push('<span class="focus-badge" title="Darkblade of the Warlord">Darkblade</span>');
                    }
                    if (focusItems.has_raex_chest) {
                        badges.push('<span class="focus-badge" title="Raex\'s Chestplate of Destruction">Raex Chest</span>');
                    }
                    if (focusItems.has_haste) {
                        badges.push('<span class="focus-badge" title="Max Haste (100%)">Haste âœ“</span>');
                    }
                    damageBadges = badges.length > 0 ? badges.join(' ') : '<span style="color: #6c757d;">-</span>';
                    otherBadges = '<span style="color: #6c757d;">-</span>'; // Warriors don't have other focii
                } else if (charClass === 'Paladin' || charClass === 'Shadow Knight') {
                    // For Pal/SK, show Shield of Strife
                    const focusItems = scores.focus_items || {};
                    if (focusItems.has_shield) {
                        damageBadges = '<span class="focus-badge" title="Shield of Strife">Shield of Strife âœ“</span>';
                    } else {
                        damageBadges = '<span class="focus-badge" style="opacity: 0.3;">No Shield</span>';
                    }
                    otherBadges = ''; // Pal/SK don't have other focii
                } else {
                    // Check if this is a pure melee class (no caster focuses)
                    const pureMeleeClasses = ['Warrior', 'Monk', 'Rogue'];
                    const isPureMelee = pureMeleeClasses.includes(charClass);
                    
                    if (isPureMelee) {
                        // Pure melees don't have caster focuses
                        damageBadges = '<span style="color: #6c757d;">-</span>';
                        otherBadges = '<span style="color: #6c757d;">-</span>';
                    } else {
                        // Get damage-specific focii - show all damage types the character has
                        // (even if not weighted, so users can see what they have)
                        const damageFocii = char.damage_focii || {};
                        const allDamageFocii = Object.entries(damageFocii)
                            .sort((a, b) => b[1] - a[1]);
                        
                        // Highlight weighted damage types, show others too
                        damageBadges = allDamageFocii
                            .map(([type, pct]) => {
                                const isWeighted = spellDamageWeights.hasOwnProperty(type);
                                const weight = spellDamageWeights[type] || 0;
                                const title = isWeighted 
                                    ? `${type} Damage: ${pct}% (weighted: ${weight})`
                                    : `${type} Damage: ${pct}% (not weighted for ${charClass})`;
                                const style = isWeighted ? '' : 'opacity: 0.6;';
                                return `<span class="focus-badge" title="${title}" style="${style}">${type} ${pct}%</span>`;
                            }).join('');
                        
                        // Get other focii - show all focii the character has
                        // Highlight weighted ones, show others with reduced opacity
                        const relevantFocusCats = Object.keys(focusWeights).filter(cat => cat !== 'Spell Damage');
                        
                        // Build focus display with categories
                        const focusDisplay = [];
                    
                    // Helper function to format focus with category
                    const formatFocusWithCategory = (baseName, category, pct, isWeighted, weight) => {
                        const catAbbrev = {
                            'Det': 'Det',
                            'Bene': 'Bene',
                            'Nuke': '',
                            'Sanguine': 'Sanguine',
                            'All': 'All'
                        }[category] || '';
                        
                        // Format: "Bene Spell Haste 30%" or "Mana Efficiency 25%" (no prefix for Nuke)
                        let displayName = baseName;
                        if (catAbbrev) {
                            displayName = `${catAbbrev} ${baseName}`;
                        }
                        
                        const title = isWeighted 
                            ? `${baseName} (${category}): ${pct}% (weighted: ${weight})`
                            : `${baseName} (${category}): ${pct}% (not weighted for ${charClass})`;
                        const style = isWeighted ? '' : 'opacity: 0.6;';
                        return `<span class="focus-badge" title="${title}" style="${style}">${displayName} ${pct}%</span>`;
                    };
                    
                    // Handle Mana Efficiency with categories
                    if (focii['Spell Mana Efficiency'] > 0) {
                        const manaEffCats = char.mana_efficiency_cats || {};
                        Object.entries(manaEffCats).sort((a, b) => b[1] - a[1]).forEach(([cat, pct]) => {
                            // Skip Sanguine (self-only) - don't display it
                            if (cat === 'Sanguine') return;
                            
                            const isWeighted = relevantFocusCats.includes('Spell Mana Efficiency');
                            const weight = focusWeights['Spell Mana Efficiency'] || 0;
                            // For Nuke, show "Mana Efficiency" (no prefix), others show category prefix
                            const baseName = 'Mana Efficiency';
                            focusDisplay.push(formatFocusWithCategory(baseName, cat, pct, isWeighted, weight));
                        });
                    }
                    
                    // Handle Spell Haste with categories
                    if (focii['Spell Haste'] > 0) {
                        const hasteCats = char.spell_haste_cats || {};
                        Object.entries(hasteCats).sort((a, b) => b[1] - a[1]).forEach(([cat, pct]) => {
                            // Check for specific haste category weight: 'Bene' -> 'Beneficial Spell Haste', 'Det' -> 'Detrimental Spell Haste'
                            const hasteWeightKey = cat === 'Bene' ? 'Beneficial Spell Haste' : 'Detrimental Spell Haste';
                            const isWeighted = relevantFocusCats.includes(hasteWeightKey);
                            const weight = focusWeights[hasteWeightKey] || 0;
                            focusDisplay.push(formatFocusWithCategory('Spell Haste', cat, pct, isWeighted, weight));
                        });
                    }
                    
                    // Handle Duration with categories
                    // Only show relevant categories for each duration type to avoid duplicates
                    if (focii['Buff Spell Duration'] > 0) {
                        const durCats = char.duration_cats || {};
                        // Buff Spell Duration: show 'Bene' and 'All' only
                        ['Bene', 'All'].forEach(cat => {
                            if (durCats[cat] !== undefined && durCats[cat] > 0) {
                                const isWeighted = relevantFocusCats.includes('Buff Spell Duration');
                                const weight = focusWeights['Buff Spell Duration'] || 0;
                                const displayCat = cat === 'All' ? 'All' : 'Bene';
                                focusDisplay.push(formatFocusWithCategory('Duration', displayCat, durCats[cat], isWeighted, weight));
                            }
                        });
                    }
                    if (focii['Detrimental Spell Duration'] > 0) {
                        const durCats = char.duration_cats || {};
                        // Detrimental Spell Duration: show 'Det' and 'All' only
                        ['Det', 'All'].forEach(cat => {
                            if (durCats[cat] !== undefined && durCats[cat] > 0) {
                                const isWeighted = relevantFocusCats.includes('Detrimental Spell Duration');
                                const weight = focusWeights['Detrimental Spell Duration'] || 0;
                                const displayCat = cat === 'All' ? 'All' : 'Det';
                                focusDisplay.push(formatFocusWithCategory('Duration', displayCat, durCats[cat], isWeighted, weight));
                            }
                        });
                    }
                    if (focii['All Spell Duration'] > 0) {
                        const durCats = char.duration_cats || {};
                        // All Spell Duration: show 'All' only
                        if (durCats['All'] !== undefined && durCats['All'] > 0) {
                            const isWeighted = relevantFocusCats.includes('All Spell Duration');
                            const weight = focusWeights['All Spell Duration'] || 0;
                            focusDisplay.push(formatFocusWithCategory('Duration', 'All', durCats['All'], isWeighted, weight));
                        }
                    }
                    
                    // Handle other focii (Healing Enhancement, Range Extension, etc.)
                    const otherFocii = Object.entries(focii)
                        .filter(([cat]) => !['Spell Damage', 'Spell Mana Efficiency', 'Spell Haste', 
                                             'Buff Spell Duration', 'Detrimental Spell Duration', 'All Spell Duration'].includes(cat))
                        .sort((a, b) => {
                            const aWeighted = relevantFocusCats.includes(a[0]);
                            const bWeighted = relevantFocusCats.includes(b[0]);
                            if (aWeighted && !bWeighted) return -1;
                            if (!aWeighted && bWeighted) return 1;
                            return b[1] - a[1];
                        });
                    
                    otherFocii.forEach(([cat, pct]) => {
                        const isWeighted = relevantFocusCats.includes(cat);
                        const weight = focusWeights[cat] || 0;
                        // Shorten names: "Healing Enhancement" -> "Healing", "Range Extension" -> "Range Ext"
                        let shortName = cat.replace('Spell ', '');
                        if (shortName === 'Healing Enhancement') shortName = 'Healing';
                        else if (shortName === 'Spell Range Extension') shortName = 'Range Ext';
                        const title = isWeighted 
                            ? `${cat}: ${pct}% (weighted: ${weight})`
                            : `${cat}: ${pct}% (not weighted for ${charClass})`;
                        const style = isWeighted ? '' : 'opacity: 0.6;';
                        focusDisplay.push(`<span class="focus-badge" title="${title}" style="${style}">${shortName} ${pct}%</span>`);
                    });
                    
                        // Join with commas and spaces
                        otherBadges = focusDisplay.length > 0 ? focusDisplay.join(', ') : '<span style="color: #6c757d;">-</span>';
                    }
                }
                
                // Format actual stat values
                const formatStat = (value, statName) => {
                    if (value === null || value === undefined) {
                        if (statName === 'ac') return '0';  // AC defaults to 0 if missing
                        return 'N/A';
                    }
                    if (statName === 'haste') {
                        // Haste is binary: show "100% âœ“" if max (30% item = 100% total), otherwise actual item value
                        // Get haste_value from scores, not from the value parameter
                        const hasteValue = scores.haste_value;
                        if (hasteValue === null || hasteValue === undefined) return 'N/A';
                        // Check if it's actually a number, not a string like "255 / 250"
                        if (typeof hasteValue === 'number') {
                            return hasteValue >= 30 ? '100% âœ“' : `${hasteValue}%`;
                        }
                        return 'N/A';
                    }
                    if (statName === 'atk') {
                        // ATK shows as "current / 250"
                        if (typeof value === 'string' && value.includes(' / ')) {
                            return value;
                        }
                        return value || '0 / 250';
                    }
                    if (statName === 'ac') {
                        // AC - ensure we convert to number and format properly
                        const acValue = typeof value === 'number' ? value : parseInt(value) || 0;
                        return acValue.toLocaleString();
                    }
                    // For other stats, convert to number if needed and format
                    const numValue = typeof value === 'number' ? value : (parseInt(value) || 0);
                    return numValue.toLocaleString();
                };
                
                // Build row cells in exact order matching headers
                const cells = [];
                
                // Rank, Class Rank, Name, Guild, Class, Overall (fixed columns - indices 0-5)
                cells.push(`<td class="rank">#${char.overall_rank || index + 1}</td>`);
                cells.push(`<td class="rank">#${char.class_rank || '-'}</td>`);
                cells.push(`<td class="name"><a href="https://www.takproject.net/magelo/character.php?char=${encodeURIComponent(char.name)}" target="_blank">${escapeHtml(char.name)}</a></td>`);
                cells.push(`<td>${escapeHtml(char.guild || '')}</td>`);
                cells.push(`<td>${escapeHtml(char.class || '')}</td>`);
                cells.push(`<td class="score ${getScoreClass(char.overall_score)}">${formatScore(char.overall_score)}</td>`);
                
                // Stat columns (in header order - indices 6-10)
                // Index 6: HP
                cells.push(`<td class="stat-col" data-stat="hp">${formatStat(char.stats.hp, 'hp')}</td>`);
                // Index 7: Mana
                cells.push(`<td class="stat-col" data-stat="mana">${formatStat(char.stats.mana, 'mana')}</td>`);
                // Index 8: AC - check both stats.ac and scores.ac, ensure it's a number
                const acValue = (char.stats.ac !== undefined && char.stats.ac !== null) 
                    ? (typeof char.stats.ac === 'number' ? char.stats.ac : parseInt(char.stats.ac) || 0)
                    : ((scores.ac !== undefined && scores.ac !== null) 
                        ? (typeof scores.ac === 'number' ? scores.ac : parseInt(scores.ac) || 0)
                        : 0);
                cells.push(`<td class="stat-col" data-stat="ac">${acValue.toLocaleString()}</td>`);
                // Index 9: ATK
                cells.push(`<td class="stat-col" data-stat="atk">${formatStat(char.stats.atk_item, 'atk')}</td>`);
                // Index 10: Resists - total resists value
                const resistsValue = scores.resists !== null && scores.resists !== undefined ? scores.resists : 0;
                const resistsDisplay = resistsValue > 0 ? resistsValue.toLocaleString() : 'N/A';
                cells.push(`<td class="stat-col" data-stat="resists">${resistsDisplay}</td>`);
                
                // Focus %, Spell Dmg %, Damage Types, Other Focii (fixed columns - indices 11-14)
                // IMPORTANT: Always create all 15 cells in exact header order to maintain alignment
                cells.push(`<td class="score">${formatScore(scores.focus_overall_pct)}</td>`);  // Index 11: Focus %
                cells.push(`<td class="stat-col score ${spellDmgScore !== null ? getScoreClass(spellDmgScore) : ''}" data-stat="spelldmg">${formatScore(spellDmgScore)}</td>`);  // Index 12: Spell Dmg %
                // Damage Types - ensure we're using the badges, not a score
                const damageTypesDisplay = damageBadges || '<span style="color: #6c757d;">-</span>';
                cells.push(`<td>${damageTypesDisplay}</td>`);  // Index 13: Damage Types
                // Other Focii - ensure we're using the badges, not a score
                const otherFociiDisplay = otherBadges || '<span style="color: #6c757d;">-</span>';
                cells.push(`<td>${otherFociiDisplay}</td>`);  // Index 14: Other Focii
                
                // Verify we have exactly 15 cells (matching 15 headers)
                if (cells.length !== 15) {
                    console.error(`Row for ${char.name} has ${cells.length} cells, expected 15`);
                    console.error('Cells:', cells.map((c, i) => `${i}: ${c.substring(0, 50)}`));
                }
                
                // Debug: Log first few rows to verify column alignment
                if (index < 3) {
                    console.log(`Row ${index} (${char.name}):`, {
                        ac: acValue,
                        haste: scores.haste_value,
                        damageBadges: damageBadges.substring(0, 50),
                        otherBadges: otherBadges.substring(0, 50),
                        cellCount: cells.length
                    });
                }
                
                row.innerHTML = cells.join('');
                row.classList.add('clickable-row');
                row.addEventListener('click', (e) => {
                    // Don't trigger if clicking directly on a link
                    // But allow clicks on badges and other elements to trigger the modal
                    const target = e.target;
                    const isDirectLink = target.tagName === 'A';
                    if (!isDirectLink) {
                        // Check if we're inside a link (e.g., character name link)
                        const linkParent = target.closest('a');
                        if (!linkParent) {
                            // Not clicking on a link, show the modal
                            showScoreBreakdown(char);
                        }
                    }
                });
                
                tbody.appendChild(row);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.getElementById('filterClass').addEventListener('change', (e) => {
            filterClass = e.target.value;
            filterAndSort();
        });

        document.getElementById('sortBy').addEventListener('change', (e) => {
            sortBy = e.target.value;
            filterAndSort();
        });

        // Modal functionality
        const modal = document.getElementById('scoreModal');
        const closeBtn = document.getElementsByClassName('close')[0];

        closeBtn.onclick = function() {
            modal.style.display = 'none';
        };

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };

        function showScoreBreakdown(char) {
            const modal = document.getElementById('scoreModal');
            const modalContent = document.getElementById('modalContent');
            const scores = char.scores || {};
            
            // Get the same weights used in recalculateScores (including custom weights)
            const charClass = char.class;
            const customWeight = customWeights[charClass] || {};
            const focusMultiplier = customWeight._meta?.focusMultiplier || 2.4;
            
            let weights = JSON.parse(JSON.stringify(originalClassWeights[charClass] || classWeights[charClass] || {}));
            
            // Apply custom weights (same logic as recalculateScores)
            Object.keys(customWeight).forEach(key => {
                if (key !== '_meta' && key !== 'focus' && weights.hasOwnProperty(key)) {
                    weights[key] = customWeight[key];
                }
            });
            
            // Apply custom focus weights
            if (customWeight.focus && weights.focus) {
                Object.keys(customWeight.focus).forEach(focusKey => {
                    if (weights.focus[focusKey] !== undefined) {
                        if (typeof customWeight.focus[focusKey] === 'object' && customWeight.focus[focusKey] !== null) {
                            if (!weights.focus[focusKey]) {
                                weights.focus[focusKey] = {};
                            }
                            Object.keys(customWeight.focus[focusKey]).forEach(nestedKey => {
                                if (weights.focus[focusKey][nestedKey] !== undefined) {
                                    weights.focus[focusKey][nestedKey] = customWeight.focus[focusKey][nestedKey];
                                }
                            });
                        } else {
                            weights.focus[focusKey] = customWeight.focus[focusKey];
                        }
                    }
                });
            }
            
            // Normalize weights (same as recalculateScores)
            const normalized = normalizeWeights(weights, focusMultiplier);
            const classWeightConfig = weights; // Use the weights (not normalized) for display
            const focusWeights = normalized.focus || {};
            
            let html = `<h2>${escapeHtml(char.name)} (${escapeHtml(char.class)})</h2>`;
            html += `<p><a href="https://www.takproject.net/magelo/character.php?char=${encodeURIComponent(char.name)}" target="_blank">View on Magelo</a></p>`;
            html += `<div class="score-breakdown">`;
            
            // Initialize totals
            let totalStatPoints = 0.0;
            let totalFocusPoints = 0.0;
            
            html += `<h3>Overall Score: ${formatScore(char.overall_score)}%</h3>`;
            
            // Stat Scores
            html += `<h3>Stat Scores</h3>`;
            html += `<table><thead><tr><th>Stat</th><th>Value</th><th>Score %</th><th>Weight</th><th>Points</th></tr></thead><tbody>`;
            
            // HP - use normalized weight for calculation, but show raw weight for display
            if (scores.hp_pct !== undefined && normalized.hp_pct > 0) {
                const normalizedWeight = normalized.hp_pct;  // For calculation (0.20 = 20% contribution)
                const rawWeight = weights.hp_pct || 1.0;  // Raw weight for display (1.0 = 20% target)
                const hpValue = char.stats.hp || 0;
                const hpPct = scores.hp_pct;
                const points = hpPct * normalizedWeight;  // Use normalized for calculation
                totalStatPoints += points;
                html += `<tr><td>HP</td><td>${hpValue.toLocaleString()}</td><td>${formatScore(hpPct)}</td><td>${rawWeight.toFixed(2)}</td><td>${points.toFixed(2)}</td></tr>`;
            }
            
            // Mana - use normalized weight for calculation, but show raw weight for display
            if (scores.mana_pct !== undefined && normalized.mana_pct > 0) {
                const normalizedWeight = normalized.mana_pct;  // For calculation
                const rawWeight = weights.mana_pct || 0.0;  // Raw weight for display
                const manaValue = char.stats.mana || 0;
                const manaPct = scores.mana_pct;
                const points = manaPct * normalizedWeight;  // Use normalized for calculation
                totalStatPoints += points;
                html += `<tr><td>Mana</td><td>${manaValue.toLocaleString()}</td><td>${formatScore(manaPct)}</td><td>${rawWeight.toFixed(2)}</td><td>${points.toFixed(2)}</td></tr>`;
            }
            
            // AC - use normalized weight for calculation, but show raw weight for display
            if (scores.ac_pct !== undefined && normalized.ac_pct > 0) {
                const normalizedWeight = normalized.ac_pct;  // For calculation
                const rawWeight = weights.ac_pct || 0.0;  // Raw weight for display
                const acValue = char.stats.ac || 0;
                const acPct = scores.ac_pct;
                const points = acPct * normalizedWeight;  // Use normalized for calculation
                totalStatPoints += points;
                html += `<tr><td>AC</td><td>${acValue.toLocaleString()}</td><td>${formatScore(acPct)}</td><td>${rawWeight.toFixed(2)}</td><td>${points.toFixed(2)}</td></tr>`;
            }
            
            // ATK is now in Focus Scores, not Stat Scores - skip it here
            
            // Resists - show individual resists if available and advanced mode is on
            if (scores.resists !== undefined && scores.resists !== null || scores.resists_pct !== undefined) {
                const normalizedResistWeight = normalized.resists_pct;  // For calculation
                const rawResistWeight = weights.resists_pct || 1.0;  // Raw weight for display (1.0 = 17.5% target)
                const resistsValue = scores.resists !== undefined && scores.resists !== null ? scores.resists : 0;
                
                // Show individual resists if available
                const individualResistScores = scores.individual_resist_scores;
                const charIndividualResists = char.individual_resists || {};
                
                if (individualResistScores && Object.keys(individualResistScores).length > 0 && advancedResists) {
                    html += `<tr><td colspan="5"><strong>Resists (Advanced)</strong></td></tr>`;
                    const resistTypes = ['MR', 'FR', 'CR', 'DR', 'PR'];
                    const numResists = resistTypes.filter(rt => individualResistScores[rt] && individualResistScores[rt].value > 0).length || 5;
                    const resistWeightPerResist = normalizedResistWeight / numResists;  // Total normalized weight divided by number of resists
                    let totalRawValue = 0;
                    let totalAdvancedPoints = 0;
                    let totalResistScore = 0;
                    let totalResistWeight = 0;
                    
                    resistTypes.forEach(resistType => {
                        const resistData = individualResistScores[resistType];
                        if (resistData) {
                            totalRawValue += resistData.value;
                            // Weight per resist is total weight / num_resists
                            const effectiveWeight = resistWeightPerResist * resistData.weight;  // weight is always 1.0
                            const resistPoints = resistData.score * effectiveWeight;
                            totalAdvancedPoints += resistPoints;
                            totalResistScore += resistData.score * effectiveWeight;
                            totalResistWeight += effectiveWeight;
                            // Display the per-resist weight (total weight / num_resists)
                            html += `<tr><td style="padding-left: 20px;">${resistType}</td><td>${resistData.value}</td><td>${formatScore(resistData.score)}</td><td>${resistWeightPerResist.toFixed(2)}</td><td>${resistPoints.toFixed(2)}</td></tr>`;
                        }
                    });
                    
                    // Calculate average resist score percentage
                    const avgResistPct = totalResistWeight > 0 ? (totalResistScore / totalResistWeight) : (scores.resists_pct || 0);
                    
                    html += `<tr><td><strong>Total</strong></td><td><strong>${totalRawValue.toLocaleString()}</strong></td><td><strong>${formatScore(avgResistPct)}</strong></td><td><strong>${rawResistWeight.toFixed(2)}</strong></td><td><strong>${totalAdvancedPoints.toFixed(2)}</strong></td></tr>`;
                    totalStatPoints += totalAdvancedPoints;
                } else {
                    // Use simple total resists
                    const resistsPct = (scores.resists_pct !== undefined && scores.resists_pct !== null && typeof scores.resists_pct === 'number') ? scores.resists_pct : 0;
                    const resistsPoints = resistsPct * normalizedResistWeight;  // Use normalized weight for calculation
                    totalStatPoints += resistsPoints;
                    html += `<tr><td>Resists</td><td>${resistsValue.toLocaleString()}</td><td>${formatScore(resistsPct)}</td><td>${rawResistWeight.toFixed(2)}</td><td>${resistsPoints.toFixed(2)}</td></tr>`;
                }
            }
            
            // Total stat points
            html += `<tr style="border-top: 2px solid #333; font-weight: bold;"><td><strong>Stat Total</strong></td><td colspan="3"></td><td><strong>${totalStatPoints.toFixed(2)}</strong></td></tr>`;
            html += `</tbody></table>`;
            
            // Focus Scores
            const focusScores = scores.focus_scores || {};
            const charFocii = char.focii || {};
            const charDamageFocii = char.damage_focii || {};
            const charManaEffCats = char.mana_efficiency_cats || {};
            const charSpellHasteCats = char.spell_haste_cats || {};
            const charDurationCats = char.duration_cats || {};
            
            if (Object.keys(focusScores).length > 0) {
                html += `<h3>Focus Scores</h3>`;
                html += `<table><thead><tr><th>Focus</th><th>Raw Value</th><th>Score %</th><th>Weight</th><th>Points</th></tr></thead><tbody>`;
                
                // For Warriors/Pal/SK, calculate focus weight as 2.4x HP weight (after normalization)
                // For other classes, use the focus weights from config
                let totalFocusWeight = 0;
                const charClass = char.class || '';
                if (charClass === 'Warrior' || charClass === 'Paladin' || charClass === 'Shadow Knight') {
                    // Calculate normalized weights first
                    // Sum all stat weights
                    let totalStatWeight = 0;
                    // ATK and Haste are now in focus weights, not stat weights
            const statKeys = ['hp_pct', 'mana_pct', 'ac_pct', 'resists_pct'];
                    statKeys.forEach(key => {
                        totalStatWeight += classWeightConfig[key] || 0;
                    });
                    
                    // Calculate total focus weight (2.4x HP weight before normalization)
                    const rawHpWeight = classWeightConfig.hp_pct || 0;
                    const rawFocusWeight = rawHpWeight * 2.4;
                    
                    // Total weight before normalization = stat weights + focus weights
                    const totalRawWeight = totalStatWeight + rawFocusWeight;
                    
                    // Normalized focus weight = (raw focus weight / total raw weight)
                    if (totalRawWeight > 0) {
                        totalFocusWeight = rawFocusWeight / totalRawWeight;
                    }
                } else {
                    // Sum all focus weights (these are already normalized in the JSON)
                    for (const [cat, weight] of Object.entries(focusWeights)) {
                        if (typeof weight === 'object') {
                            totalFocusWeight += Object.values(weight).reduce((a, b) => a + b, 0);
                        } else {
                            totalFocusWeight += weight;
                        }
                    }
                }
                
                // Helper function to get raw value for a focus category
                function getRawFocusValue(focusCat) {
                    if (focusCat === 'Spell Damage') {
                        // Get the best damage type value
                        const damageTypes = Object.keys(charDamageFocii);
                        if (damageTypes.length > 0) {
                            const bestType = damageTypes.reduce((a, b) => charDamageFocii[a] > charDamageFocii[b] ? a : b);
                            return charDamageFocii[bestType] || 0;
                        }
                        return 0;
                    } else if (focusCat === 'Spell Mana Efficiency') {
                        // Get the best mana efficiency category
                        const cats = Object.keys(charManaEffCats);
                        if (cats.length > 0) {
                            const bestCat = cats.reduce((a, b) => charManaEffCats[a] > charManaEffCats[b] ? a : b);
                            return charManaEffCats[bestCat] || 0;
                        }
                        return 0;
                    } else if (focusCat === 'Beneficial Spell Haste' || focusCat === 'Detrimental Spell Haste') {
                        const hasteCat = focusCat === 'Beneficial Spell Haste' ? 'Bene' : 'Det';
                        return charSpellHasteCats[hasteCat] || 0;
                    } else if (focusCat === 'Buff Spell Duration' || focusCat === 'Beneficial Spell Duration') {
                        // All Spell Duration counts for Buff at its %; use max(Bene, All)
                        return Math.max(charDurationCats['Bene'] || 0, charDurationCats['All'] || 0);
                    } else if (focusCat === 'Detrimental Spell Duration') {
                        // All Spell Duration counts for Det at its %; use max(Det, All)
                        return Math.max(charDurationCats['Det'] || 0, charDurationCats['All'] || 0);
                    } else if (focusCat === 'All Spell Duration') {
                        return charDurationCats['All'] || 0;
                    } else if (focusCat === 'Haste') {
                        // Haste is binary, show the item haste value
                        const hasteValue = char.stats?.haste || 0;
                        return hasteValue >= 30 ? 30 : hasteValue;
                    } else if (focusCat === "Time's Antithesis" || focusCat === 'Serpent of Vindication') {
                        // Binary item focus: 100 if has item, 0 otherwise
                        return (focusScores[focusCat] === 100) ? 100 : 0;
                    } else {
                        // For other focuses, get from charFocii
                        return charFocii[focusCat] || 0;
                    }
                }
                
                for (const [focusCat, score] of Object.entries(focusScores)) {
                    if (focusCat === 'FT') continue;  // FT shown in dedicated block below (uses normalized.ft_weight)
                    let weight = 0;
                    let rawValue = getRawFocusValue(focusCat);
                    
                    if (focusCat === 'Spell Damage') {
                        // Spell Damage has nested weights
                        const damageWeights = focusWeights['Spell Damage'] || {};
                        weight = Object.values(damageWeights).reduce((a, b) => a + b, 0);
                    } else if (focusCat === 'Haste') {
                        // Use normalized weight from focusWeights (which is already normalized)
                        weight = focusWeights[focusCat] || 0;
                    } else if (focusCat === 'Darkblade' || focusCat === 'Raex Chest') {
                        // Warrior focus items - use normalized weight from focusWeights
                        weight = focusWeights[focusCat];
                        if (weight === undefined || weight === null) {
                            // Debug: log what's in focusWeights and raw focus dict
                            const rawWeights = originalClassWeights[charClass] || classWeights[charClass] || {};
                            const rawFocus = rawWeights.focus || {};
                            console.warn(`Weight missing for ${focusCat}. Available normalized focus weights:`, Object.keys(focusWeights));
                            console.warn(`Raw focus dict for ${charClass}:`, rawFocus);
                            console.warn(`Raw weights for ${charClass}:`, rawWeights);
                            weight = 0;
                        }
                        // These are binary (100 or 0), so raw value is the score
                        rawValue = score === 100 ? 100 : 0;
                    } else if (focusCat === 'Shield of Strife' || focusCat === 'Serpent of Vindication' || 
                               focusCat === 'Healing Enhancement' || focusCat === 'Beneficial Spell Haste' || 
                               focusCat === 'ATK') {
                        // For specific focus items, use normalized weight from focusWeights
                        weight = focusWeights[focusCat] || 0;
                        
                        if (focusCat === 'Shield of Strife' || focusCat === 'Serpent of Vindication') {
                            // These are binary (100 or 0), so raw value is the score
                            rawValue = score === 100 ? 100 : 0;
                        } else if (focusCat === 'Haste') {
                            // Haste is binary, show the item haste value
                            const hasteValue = char.stats?.haste || 0;
                            rawValue = hasteValue >= 30 ? 30 : hasteValue;
                        }
                    } else {
                        weight = focusWeights[focusCat] || 0;
                    }
                    
                    // Format raw value
                    let rawDisplay = 'N/A';
                    if (rawValue > 0) {
                        if (focusCat === 'Haste') {
                            rawDisplay = `${rawValue}% (${rawValue >= 30 ? 'Capped' : 'Not Capped'})`;
                        } else {
                            rawDisplay = `${rawValue.toFixed(1)}%`;
                        }
                    }
                    
                    const focusPoints = score * weight;
                    totalFocusPoints += focusPoints;
                    
                    html += `<tr><td>${escapeHtml(focusCat)}</td><td>${rawDisplay}</td><td>${formatScore(score)}</td><td>${weight.toFixed(2)}</td><td>${focusPoints.toFixed(2)}</td></tr>`;
                }
                
                // FT (Flowing Thought) - part of focus weight; points proportional to % (11/15 = 73.3% of weight)
                const ftWeight = normalized.ft_weight || 0;
                if (ftWeight > 0 && (scores.ft_capped !== undefined || scores.ft_current !== undefined)) {
                    const ftCurrent = scores.ft_current != null ? scores.ft_current : 0;
                    const ftCap = scores.ft_cap != null ? scores.ft_cap : 15;
                    const ftPct = scores.ft_capped ? 100 : (scores.ft_pct != null ? scores.ft_pct : 0);
                    const ftPoints = (ftPct / 100.0) * ftWeight;
                    totalFocusPoints += ftPoints;
                    html += `<tr><td>FT (Flowing Thought)</td><td>${ftCurrent}/${ftCap}</td><td>${formatScore(ftPct)}</td><td>${ftWeight.toFixed(2)}</td><td>${ftPoints.toFixed(2)}</td></tr>`;
                }
                
                // ATK - part of focus weight (only show if not already in focus_scores)
                if (scores.atk_pct !== undefined && scores.atk_pct !== null && !focusScores['ATK']) {
                    // Use normalized weight from focusWeights
                    const atkWeight = focusWeights['ATK'] || 0;
                    if (atkWeight > 0) {
                        const atkPoints = scores.atk_pct * atkWeight;
                        totalFocusPoints += atkPoints;
                        html += `<tr><td>ATK</td><td>${char.stats.atk_item || 'N/A'}</td><td>${formatScore(scores.atk_pct)}</td><td>${atkWeight.toFixed(2)}</td><td>${atkPoints.toFixed(2)}</td></tr>`;
                    }
                }
                
                // Haste - part of focus weight (only show if not already in focus_scores)
                if (scores.haste_pct !== undefined && scores.haste_pct !== null && !focusScores['Haste']) {
                    // Use normalized weight from focusWeights
                    const hasteWeight = focusWeights['Haste'] || 0;
                    if (hasteWeight > 0) {
                        const hastePoints = scores.haste_pct * hasteWeight;
                        totalFocusPoints += hastePoints;
                        html += `<tr><td>Haste</td><td>${scores.haste_value || 'N/A'}%</td><td>${formatScore(scores.haste_pct)}</td><td>${hasteWeight.toFixed(2)}</td><td>${hastePoints.toFixed(2)}</td></tr>`;
                    }
                }
                
                // Total focus points
                html += `<tr style="border-top: 2px solid #333; font-weight: bold;"><td><strong>Focus Total</strong></td><td colspan="3"></td><td><strong>${totalFocusPoints.toFixed(2)}</strong></td></tr>`;
                html += `</tbody></table>`;
                
                // Overall total - ALWAYS use stored total_points from recalculateScores
                // This ensures consistency with the ranking calculation
                const overallTotal = char.total_points !== undefined ? char.total_points : (totalStatPoints + totalFocusPoints);
                html += `<h3 style="margin-top: 20px;">Overall Total: ${overallTotal.toFixed(2)} points</h3>`;
                // Calculate class maximum safely
                let classMaxDisplay = 'N/A';
                if (char.overall_score > 0 && char.total_points !== undefined) {
                    const classMax = char.total_points / (char.overall_score / 100.0);
                    if (!isNaN(classMax) && isFinite(classMax)) {
                        classMaxDisplay = classMax.toFixed(2);
                    }
                }
                html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum of ${classMaxDisplay} points)</p>`;
            } else {
                // No focus scores, just show stat total
                const overallTotal = char.total_points !== undefined ? char.total_points : totalStatPoints;
                html += `<h3 style="margin-top: 20px;">Overall Total: ${overallTotal.toFixed(2)} points</h3>`;
                if (char.overall_score > 0 && char.total_points !== undefined) {
                    const maxForClass = char.total_points / (char.overall_score / 100.0);
                    if (!isNaN(maxForClass) && isFinite(maxForClass)) {
                        html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum of ${maxForClass.toFixed(2)} points)</p>`;
                    } else {
                        html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum)</p>`;
                    }
                } else {
                    html += `<p style="color: #6c757d; font-size: 0.9em;">Overall Score: ${formatScore(char.overall_score)}% (normalized by class maximum)</p>`;
                }
            }
            
            // Gear display with item links
            if (char.inventory && char.inventory.length > 0) {
                html += `<h3>Equipped Gear</h3>`;
                html += `<div style="display: flex; flex-wrap: wrap; gap: 10px;">`;
                const slotNames = {
                    0: 'Charm', 1: 'Ear', 2: 'Head', 3: 'Face', 4: 'Ear', 5: 'Neck',
                    6: 'Shoulder', 7: 'Arms', 8: 'Back', 9: 'Wrist', 10: 'Wrist',
                    11: 'Range', 12: 'Hands', 13: 'Main Hand', 14: 'Off Hand',
                    15: 'Primary', 16: 'Secondary', 17: 'Chest', 18: 'Legs',
                    19: 'Feet', 20: 'Waist', 21: 'Power Source', 22: 'Ammo'
                };
                char.inventory.forEach(item => {
                    const slotName = slotNames[item.slot_id] || `Slot ${item.slot_id}`;
                    const itemLink = `<a href="https://www.takproject.net/allaclone/item.php?id=${item.item_id}" target="_blank">${escapeHtml(item.item_name || `Item ${item.item_id}`)}</a>`;
                    html += `<div style="padding: 5px; background: #f0f0f0; border-radius: 3px;"><strong>${slotName}:</strong> ${itemLink}</div>`;
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            modalContent.innerHTML = html;
            modal.style.display = 'block';
        }

        loadData();
    </script>
</body>
</html>
